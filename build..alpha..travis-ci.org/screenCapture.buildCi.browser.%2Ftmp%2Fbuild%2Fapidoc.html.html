<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/mongodb/js-bson#readme">bson (v1.0.4)</a>
</h1>
<h4>A bson parser for node.js and the browser</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.bson">module bson</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.bson">
            function <span class="apidocSignatureSpan"></span>bson
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.BSON">
            function <span class="apidocSignatureSpan">bson.</span>BSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.BSONRegExp">
            function <span class="apidocSignatureSpan">bson.</span>BSONRegExp
            <span class="apidocSignatureSpan">(pattern, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Binary">
            function <span class="apidocSignatureSpan">bson.</span>Binary
            <span class="apidocSignatureSpan">(buffer, subType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Code">
            function <span class="apidocSignatureSpan">bson.</span>Code
            <span class="apidocSignatureSpan">(code, scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.DBRef">
            function <span class="apidocSignatureSpan">bson.</span>DBRef
            <span class="apidocSignatureSpan">(namespace, oid, db)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Decimal128">
            function <span class="apidocSignatureSpan">bson.</span>Decimal128
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Double">
            function <span class="apidocSignatureSpan">bson.</span>Double
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Int32">
            function <span class="apidocSignatureSpan">bson.</span>Int32
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Long">
            function <span class="apidocSignatureSpan">bson.</span>Long
            <span class="apidocSignatureSpan">(low, high)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Map">
            function <span class="apidocSignatureSpan">bson.</span>Map
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.MaxKey">
            function <span class="apidocSignatureSpan">bson.</span>MaxKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.MinKey">
            function <span class="apidocSignatureSpan">bson.</span>MinKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.ObjectID">
            function <span class="apidocSignatureSpan">bson.</span>ObjectID
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.ObjectId">
            function <span class="apidocSignatureSpan">bson.</span>ObjectId
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Symbol">
            function <span class="apidocSignatureSpan">bson.</span>Symbol
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Timestamp">
            function <span class="apidocSignatureSpan">bson.</span>Timestamp
            <span class="apidocSignatureSpan">(low, high)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.</span>BSON_BINARY_SUBTYPE_BYTE_ARRAY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.</span>BSON_BINARY_SUBTYPE_DEFAULT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.</span>BSON_BINARY_SUBTYPE_FUNCTION</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.</span>BSON_BINARY_SUBTYPE_MD5</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.</span>BSON_BINARY_SUBTYPE_USER_DEFINED</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.</span>BSON_BINARY_SUBTYPE_UUID</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.</span>BSON_DATA_ARRAY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.</span>BSON_DATA_BINARY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.</span>BSON_DATA_BOOLEAN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.</span>BSON_DATA_CODE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.</span>BSON_DATA_CODE_W_SCOPE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.</span>BSON_DATA_DATE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.</span>BSON_DATA_INT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.</span>BSON_DATA_LONG</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.</span>BSON_DATA_MAX_KEY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.</span>BSON_DATA_MIN_KEY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.</span>BSON_DATA_NULL</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.</span>BSON_DATA_NUMBER</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.</span>BSON_DATA_OBJECT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.</span>BSON_DATA_OID</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.</span>BSON_DATA_REGEXP</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.</span>BSON_DATA_STRING</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.</span>BSON_DATA_SYMBOL</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.</span>BSON_DATA_TIMESTAMP</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.</span>BSON_INT32_MAX</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.</span>BSON_INT32_MIN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.</span>BSON_INT64_MAX</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.</span>BSON_INT64_MIN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.</span>JS_INT_MAX</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.</span>JS_INT_MIN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bson.</span>BSON.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bson.</span>Binary.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bson.</span>Code.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bson.</span>DBRef.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bson.</span>Decimal128.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bson.</span>Double.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bson.</span>Int32.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bson.</span>Long.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bson.</span>ObjectID.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bson.</span>Symbol.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bson.</span>Timestamp.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bson.</span>float_parser</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bson.BSON">module bson.BSON</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.BSON.BSON">
            function <span class="apidocSignatureSpan">bson.</span>BSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.BSON.BSONRegExp">
            function <span class="apidocSignatureSpan">bson.BSON.</span>BSONRegExp
            <span class="apidocSignatureSpan">(pattern, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.BSON.Binary">
            function <span class="apidocSignatureSpan">bson.BSON.</span>Binary
            <span class="apidocSignatureSpan">(buffer, subType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.BSON.Code">
            function <span class="apidocSignatureSpan">bson.BSON.</span>Code
            <span class="apidocSignatureSpan">(code, scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.BSON.DBRef">
            function <span class="apidocSignatureSpan">bson.BSON.</span>DBRef
            <span class="apidocSignatureSpan">(namespace, oid, db)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.BSON.Decimal128">
            function <span class="apidocSignatureSpan">bson.BSON.</span>Decimal128
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.BSON.Double">
            function <span class="apidocSignatureSpan">bson.BSON.</span>Double
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.BSON.Int32">
            function <span class="apidocSignatureSpan">bson.BSON.</span>Int32
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.BSON.Long">
            function <span class="apidocSignatureSpan">bson.BSON.</span>Long
            <span class="apidocSignatureSpan">(low, high)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.BSON.Map">
            function <span class="apidocSignatureSpan">bson.BSON.</span>Map
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.BSON.MaxKey">
            function <span class="apidocSignatureSpan">bson.BSON.</span>MaxKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.BSON.MinKey">
            function <span class="apidocSignatureSpan">bson.BSON.</span>MinKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.BSON.ObjectID">
            function <span class="apidocSignatureSpan">bson.BSON.</span>ObjectID
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.BSON.ObjectId">
            function <span class="apidocSignatureSpan">bson.BSON.</span>ObjectId
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.BSON.Symbol">
            function <span class="apidocSignatureSpan">bson.BSON.</span>Symbol
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.BSON.Timestamp">
            function <span class="apidocSignatureSpan">bson.BSON.</span>Timestamp
            <span class="apidocSignatureSpan">(low, high)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.BSON.</span>BSON_BINARY_SUBTYPE_BYTE_ARRAY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.BSON.</span>BSON_BINARY_SUBTYPE_DEFAULT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.BSON.</span>BSON_BINARY_SUBTYPE_FUNCTION</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.BSON.</span>BSON_BINARY_SUBTYPE_MD5</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.BSON.</span>BSON_BINARY_SUBTYPE_USER_DEFINED</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.BSON.</span>BSON_BINARY_SUBTYPE_UUID</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.BSON.</span>BSON_DATA_ARRAY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.BSON.</span>BSON_DATA_BINARY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.BSON.</span>BSON_DATA_BOOLEAN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.BSON.</span>BSON_DATA_CODE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.BSON.</span>BSON_DATA_CODE_W_SCOPE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.BSON.</span>BSON_DATA_DATE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.BSON.</span>BSON_DATA_INT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.BSON.</span>BSON_DATA_LONG</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.BSON.</span>BSON_DATA_MAX_KEY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.BSON.</span>BSON_DATA_MIN_KEY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.BSON.</span>BSON_DATA_NULL</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.BSON.</span>BSON_DATA_NUMBER</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.BSON.</span>BSON_DATA_OBJECT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.BSON.</span>BSON_DATA_OID</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.BSON.</span>BSON_DATA_REGEXP</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.BSON.</span>BSON_DATA_STRING</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.BSON.</span>BSON_DATA_SYMBOL</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.BSON.</span>BSON_DATA_TIMESTAMP</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.BSON.</span>BSON_INT32_MAX</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.BSON.</span>BSON_INT32_MIN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.BSON.</span>BSON_INT64_MAX</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.BSON.</span>BSON_INT64_MIN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.BSON.</span>JS_INT_MAX</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.BSON.</span>JS_INT_MIN</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bson.BSON.prototype">module bson.BSON.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.BSON.prototype.calculateObjectSize">
            function <span class="apidocSignatureSpan">bson.BSON.prototype.</span>calculateObjectSize
            <span class="apidocSignatureSpan">(object, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.BSON.prototype.deserialize">
            function <span class="apidocSignatureSpan">bson.BSON.prototype.</span>deserialize
            <span class="apidocSignatureSpan">(buffer, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.BSON.prototype.deserializeStream">
            function <span class="apidocSignatureSpan">bson.BSON.prototype.</span>deserializeStream
            <span class="apidocSignatureSpan">(data, startIndex, numberOfDocuments, documents, docStartIndex, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.BSON.prototype.serialize">
            function <span class="apidocSignatureSpan">bson.BSON.prototype.</span>serialize
            <span class="apidocSignatureSpan">(object, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.BSON.prototype.serializeWithBufferAndIndex">
            function <span class="apidocSignatureSpan">bson.BSON.prototype.</span>serializeWithBufferAndIndex
            <span class="apidocSignatureSpan">(object, finalBuffer, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bson.BSONRegExp">module bson.BSONRegExp</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.BSONRegExp.BSONRegExp">
            function <span class="apidocSignatureSpan">bson.</span>BSONRegExp
            <span class="apidocSignatureSpan">(pattern, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bson.Binary">module bson.Binary</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Binary.Binary">
            function <span class="apidocSignatureSpan">bson.</span>Binary
            <span class="apidocSignatureSpan">(buffer, subType)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.Binary.</span>BUFFER_SIZE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.Binary.</span>SUBTYPE_BYTE_ARRAY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.Binary.</span>SUBTYPE_DEFAULT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.Binary.</span>SUBTYPE_FUNCTION</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.Binary.</span>SUBTYPE_MD5</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.Binary.</span>SUBTYPE_USER_DEFINED</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.Binary.</span>SUBTYPE_UUID</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.Binary.</span>SUBTYPE_UUID_OLD</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bson.Binary.prototype">module bson.Binary.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Binary.prototype.length">
            function <span class="apidocSignatureSpan">bson.Binary.prototype.</span>length
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Binary.prototype.put">
            function <span class="apidocSignatureSpan">bson.Binary.prototype.</span>put
            <span class="apidocSignatureSpan">(byte_value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Binary.prototype.read">
            function <span class="apidocSignatureSpan">bson.Binary.prototype.</span>read
            <span class="apidocSignatureSpan">(position, length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Binary.prototype.toJSON">
            function <span class="apidocSignatureSpan">bson.Binary.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Binary.prototype.toString">
            function <span class="apidocSignatureSpan">bson.Binary.prototype.</span>toString
            <span class="apidocSignatureSpan">(format)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Binary.prototype.value">
            function <span class="apidocSignatureSpan">bson.Binary.prototype.</span>value
            <span class="apidocSignatureSpan">(asRaw)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Binary.prototype.write">
            function <span class="apidocSignatureSpan">bson.Binary.prototype.</span>write
            <span class="apidocSignatureSpan">(string, offset)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bson.Code">module bson.Code</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Code.Code">
            function <span class="apidocSignatureSpan">bson.</span>Code
            <span class="apidocSignatureSpan">(code, scope)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bson.Code.prototype">module bson.Code.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Code.prototype.toJSON">
            function <span class="apidocSignatureSpan">bson.Code.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bson.DBRef">module bson.DBRef</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.DBRef.DBRef">
            function <span class="apidocSignatureSpan">bson.</span>DBRef
            <span class="apidocSignatureSpan">(namespace, oid, db)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bson.DBRef.prototype">module bson.DBRef.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.DBRef.prototype.toJSON">
            function <span class="apidocSignatureSpan">bson.DBRef.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bson.Decimal128">module bson.Decimal128</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Decimal128.Decimal128">
            function <span class="apidocSignatureSpan">bson.</span>Decimal128
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Decimal128.fromString">
            function <span class="apidocSignatureSpan">bson.Decimal128.</span>fromString
            <span class="apidocSignatureSpan">(string)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bson.Decimal128.prototype">module bson.Decimal128.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Decimal128.prototype.toJSON">
            function <span class="apidocSignatureSpan">bson.Decimal128.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Decimal128.prototype.toString">
            function <span class="apidocSignatureSpan">bson.Decimal128.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bson.Double">module bson.Double</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Double.Double">
            function <span class="apidocSignatureSpan">bson.</span>Double
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bson.Double.prototype">module bson.Double.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Double.prototype.toJSON">
            function <span class="apidocSignatureSpan">bson.Double.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Double.prototype.valueOf">
            function <span class="apidocSignatureSpan">bson.Double.prototype.</span>valueOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bson.Int32">module bson.Int32</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Int32.Int32">
            function <span class="apidocSignatureSpan">bson.</span>Int32
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bson.Int32.prototype">module bson.Int32.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Int32.prototype.toJSON">
            function <span class="apidocSignatureSpan">bson.Int32.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Int32.prototype.valueOf">
            function <span class="apidocSignatureSpan">bson.Int32.prototype.</span>valueOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bson.Long">module bson.Long</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Long.Long">
            function <span class="apidocSignatureSpan">bson.</span>Long
            <span class="apidocSignatureSpan">(low, high)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Long.fromBits">
            function <span class="apidocSignatureSpan">bson.Long.</span>fromBits
            <span class="apidocSignatureSpan">(lowBits, highBits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Long.fromInt">
            function <span class="apidocSignatureSpan">bson.Long.</span>fromInt
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Long.fromNumber">
            function <span class="apidocSignatureSpan">bson.Long.</span>fromNumber
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Long.fromString">
            function <span class="apidocSignatureSpan">bson.Long.</span>fromString
            <span class="apidocSignatureSpan">(str, opt_radix)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.Long.</span>TWO_PWR_16_DBL_</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.Long.</span>TWO_PWR_24_DBL_</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.Long.</span>TWO_PWR_31_DBL_</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.Long.</span>TWO_PWR_32_DBL_</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.Long.</span>TWO_PWR_48_DBL_</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.Long.</span>TWO_PWR_63_DBL_</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.Long.</span>TWO_PWR_64_DBL_</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bson.Long.</span>INT_CACHE_</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bson.Long.</span>MAX_VALUE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bson.Long.</span>MIN_VALUE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bson.Long.</span>NEG_ONE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bson.Long.</span>ONE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bson.Long.</span>TWO_PWR_24_</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bson.Long.</span>ZERO</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bson.Long.prototype">module bson.Long.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Long.prototype.add">
            function <span class="apidocSignatureSpan">bson.Long.prototype.</span>add
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Long.prototype.and">
            function <span class="apidocSignatureSpan">bson.Long.prototype.</span>and
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Long.prototype.compare">
            function <span class="apidocSignatureSpan">bson.Long.prototype.</span>compare
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Long.prototype.div">
            function <span class="apidocSignatureSpan">bson.Long.prototype.</span>div
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Long.prototype.equals">
            function <span class="apidocSignatureSpan">bson.Long.prototype.</span>equals
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Long.prototype.getHighBits">
            function <span class="apidocSignatureSpan">bson.Long.prototype.</span>getHighBits
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Long.prototype.getLowBits">
            function <span class="apidocSignatureSpan">bson.Long.prototype.</span>getLowBits
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Long.prototype.getLowBitsUnsigned">
            function <span class="apidocSignatureSpan">bson.Long.prototype.</span>getLowBitsUnsigned
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Long.prototype.getNumBitsAbs">
            function <span class="apidocSignatureSpan">bson.Long.prototype.</span>getNumBitsAbs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Long.prototype.greaterThan">
            function <span class="apidocSignatureSpan">bson.Long.prototype.</span>greaterThan
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Long.prototype.greaterThanOrEqual">
            function <span class="apidocSignatureSpan">bson.Long.prototype.</span>greaterThanOrEqual
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Long.prototype.isNegative">
            function <span class="apidocSignatureSpan">bson.Long.prototype.</span>isNegative
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Long.prototype.isOdd">
            function <span class="apidocSignatureSpan">bson.Long.prototype.</span>isOdd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Long.prototype.isZero">
            function <span class="apidocSignatureSpan">bson.Long.prototype.</span>isZero
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Long.prototype.lessThan">
            function <span class="apidocSignatureSpan">bson.Long.prototype.</span>lessThan
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Long.prototype.lessThanOrEqual">
            function <span class="apidocSignatureSpan">bson.Long.prototype.</span>lessThanOrEqual
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Long.prototype.modulo">
            function <span class="apidocSignatureSpan">bson.Long.prototype.</span>modulo
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Long.prototype.multiply">
            function <span class="apidocSignatureSpan">bson.Long.prototype.</span>multiply
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Long.prototype.negate">
            function <span class="apidocSignatureSpan">bson.Long.prototype.</span>negate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Long.prototype.not">
            function <span class="apidocSignatureSpan">bson.Long.prototype.</span>not
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Long.prototype.notEquals">
            function <span class="apidocSignatureSpan">bson.Long.prototype.</span>notEquals
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Long.prototype.or">
            function <span class="apidocSignatureSpan">bson.Long.prototype.</span>or
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Long.prototype.shiftLeft">
            function <span class="apidocSignatureSpan">bson.Long.prototype.</span>shiftLeft
            <span class="apidocSignatureSpan">(numBits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Long.prototype.shiftRight">
            function <span class="apidocSignatureSpan">bson.Long.prototype.</span>shiftRight
            <span class="apidocSignatureSpan">(numBits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Long.prototype.shiftRightUnsigned">
            function <span class="apidocSignatureSpan">bson.Long.prototype.</span>shiftRightUnsigned
            <span class="apidocSignatureSpan">(numBits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Long.prototype.subtract">
            function <span class="apidocSignatureSpan">bson.Long.prototype.</span>subtract
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Long.prototype.toInt">
            function <span class="apidocSignatureSpan">bson.Long.prototype.</span>toInt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Long.prototype.toJSON">
            function <span class="apidocSignatureSpan">bson.Long.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Long.prototype.toNumber">
            function <span class="apidocSignatureSpan">bson.Long.prototype.</span>toNumber
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Long.prototype.toString">
            function <span class="apidocSignatureSpan">bson.Long.prototype.</span>toString
            <span class="apidocSignatureSpan">(opt_radix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Long.prototype.xor">
            function <span class="apidocSignatureSpan">bson.Long.prototype.</span>xor
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bson.Map">module bson.Map</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Map.Map">
            function <span class="apidocSignatureSpan">bson.</span>Map
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bson.MaxKey">module bson.MaxKey</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.MaxKey.MaxKey">
            function <span class="apidocSignatureSpan">bson.</span>MaxKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bson.MinKey">module bson.MinKey</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.MinKey.MinKey">
            function <span class="apidocSignatureSpan">bson.</span>MinKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bson.ObjectID">module bson.ObjectID</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.ObjectID.ObjectID">
            function <span class="apidocSignatureSpan">bson.</span>ObjectID
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.ObjectID.ObjectId">
            function <span class="apidocSignatureSpan">bson.ObjectID.</span>ObjectId
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.ObjectID.createFromHexString">
            function <span class="apidocSignatureSpan">bson.ObjectID.</span>createFromHexString
            <span class="apidocSignatureSpan">(string)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.ObjectID.createFromTime">
            function <span class="apidocSignatureSpan">bson.ObjectID.</span>createFromTime
            <span class="apidocSignatureSpan">(time)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.ObjectID.createPk">
            function <span class="apidocSignatureSpan">bson.ObjectID.</span>createPk
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.ObjectID.isValid">
            function <span class="apidocSignatureSpan">bson.ObjectID.</span>isValid
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.ObjectID.</span>index</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bson.ObjectID.prototype">module bson.ObjectID.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.ObjectID.prototype.equals">
            function <span class="apidocSignatureSpan">bson.ObjectID.prototype.</span>equals
            <span class="apidocSignatureSpan">(otherId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.ObjectID.prototype.generate">
            function <span class="apidocSignatureSpan">bson.ObjectID.prototype.</span>generate
            <span class="apidocSignatureSpan">(time)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.ObjectID.prototype.getInc">
            function <span class="apidocSignatureSpan">bson.ObjectID.prototype.</span>getInc
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.ObjectID.prototype.getTimestamp">
            function <span class="apidocSignatureSpan">bson.ObjectID.prototype.</span>getTimestamp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.ObjectID.prototype.get_inc">
            function <span class="apidocSignatureSpan">bson.ObjectID.prototype.</span>get_inc
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.ObjectID.prototype.inspect">
            function <span class="apidocSignatureSpan">bson.ObjectID.prototype.</span>inspect
            <span class="apidocSignatureSpan">(format)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.ObjectID.prototype.toHexString">
            function <span class="apidocSignatureSpan">bson.ObjectID.prototype.</span>toHexString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.ObjectID.prototype.toJSON">
            function <span class="apidocSignatureSpan">bson.ObjectID.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.ObjectID.prototype.toString">
            function <span class="apidocSignatureSpan">bson.ObjectID.prototype.</span>toString
            <span class="apidocSignatureSpan">(format)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bson.Symbol">module bson.Symbol</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Symbol.Symbol">
            function <span class="apidocSignatureSpan">bson.</span>Symbol
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bson.Symbol.prototype">module bson.Symbol.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Symbol.prototype.inspect">
            function <span class="apidocSignatureSpan">bson.Symbol.prototype.</span>inspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Symbol.prototype.toJSON">
            function <span class="apidocSignatureSpan">bson.Symbol.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Symbol.prototype.toString">
            function <span class="apidocSignatureSpan">bson.Symbol.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Symbol.prototype.valueOf">
            function <span class="apidocSignatureSpan">bson.Symbol.prototype.</span>valueOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bson.Timestamp">module bson.Timestamp</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Timestamp.Timestamp">
            function <span class="apidocSignatureSpan">bson.</span>Timestamp
            <span class="apidocSignatureSpan">(low, high)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Timestamp.fromBits">
            function <span class="apidocSignatureSpan">bson.Timestamp.</span>fromBits
            <span class="apidocSignatureSpan">(lowBits, highBits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Timestamp.fromInt">
            function <span class="apidocSignatureSpan">bson.Timestamp.</span>fromInt
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Timestamp.fromNumber">
            function <span class="apidocSignatureSpan">bson.Timestamp.</span>fromNumber
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Timestamp.fromString">
            function <span class="apidocSignatureSpan">bson.Timestamp.</span>fromString
            <span class="apidocSignatureSpan">(str, opt_radix)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.Timestamp.</span>TWO_PWR_16_DBL_</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.Timestamp.</span>TWO_PWR_24_DBL_</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.Timestamp.</span>TWO_PWR_31_DBL_</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.Timestamp.</span>TWO_PWR_32_DBL_</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.Timestamp.</span>TWO_PWR_48_DBL_</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.Timestamp.</span>TWO_PWR_63_DBL_</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bson.Timestamp.</span>TWO_PWR_64_DBL_</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bson.Timestamp.</span>INT_CACHE_</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bson.Timestamp.</span>MAX_VALUE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bson.Timestamp.</span>MIN_VALUE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bson.Timestamp.</span>NEG_ONE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bson.Timestamp.</span>ONE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bson.Timestamp.</span>TWO_PWR_24_</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bson.Timestamp.</span>ZERO</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bson.Timestamp.prototype">module bson.Timestamp.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Timestamp.prototype.add">
            function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>add
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Timestamp.prototype.and">
            function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>and
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Timestamp.prototype.compare">
            function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>compare
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Timestamp.prototype.div">
            function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>div
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Timestamp.prototype.equals">
            function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>equals
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Timestamp.prototype.getHighBits">
            function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>getHighBits
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Timestamp.prototype.getLowBits">
            function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>getLowBits
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Timestamp.prototype.getLowBitsUnsigned">
            function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>getLowBitsUnsigned
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Timestamp.prototype.getNumBitsAbs">
            function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>getNumBitsAbs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Timestamp.prototype.greaterThan">
            function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>greaterThan
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Timestamp.prototype.greaterThanOrEqual">
            function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>greaterThanOrEqual
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Timestamp.prototype.isNegative">
            function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>isNegative
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Timestamp.prototype.isOdd">
            function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>isOdd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Timestamp.prototype.isZero">
            function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>isZero
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Timestamp.prototype.lessThan">
            function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>lessThan
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Timestamp.prototype.lessThanOrEqual">
            function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>lessThanOrEqual
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Timestamp.prototype.modulo">
            function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>modulo
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Timestamp.prototype.multiply">
            function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>multiply
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Timestamp.prototype.negate">
            function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>negate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Timestamp.prototype.not">
            function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>not
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Timestamp.prototype.notEquals">
            function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>notEquals
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Timestamp.prototype.or">
            function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>or
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Timestamp.prototype.shiftLeft">
            function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>shiftLeft
            <span class="apidocSignatureSpan">(numBits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Timestamp.prototype.shiftRight">
            function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>shiftRight
            <span class="apidocSignatureSpan">(numBits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Timestamp.prototype.shiftRightUnsigned">
            function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>shiftRightUnsigned
            <span class="apidocSignatureSpan">(numBits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Timestamp.prototype.subtract">
            function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>subtract
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Timestamp.prototype.toInt">
            function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>toInt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Timestamp.prototype.toJSON">
            function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Timestamp.prototype.toNumber">
            function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>toNumber
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Timestamp.prototype.toString">
            function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>toString
            <span class="apidocSignatureSpan">(opt_radix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.Timestamp.prototype.xor">
            function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>xor
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bson.float_parser">module bson.float_parser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.float_parser.readIEEE754">
            function <span class="apidocSignatureSpan">bson.float_parser.</span>readIEEE754
            <span class="apidocSignatureSpan">(buffer, offset, endian, mLen, nBytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bson.float_parser.writeIEEE754">
            function <span class="apidocSignatureSpan">bson.float_parser.</span>writeIEEE754
            <span class="apidocSignatureSpan">(buffer, value, offset, endian, mLen, nBytes)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bson" id="apidoc.module.bson">module bson</a></h1>


    <h2>
        <a href="#apidoc.element.bson.bson" id="apidoc.element.bson.bson">
        function <span class="apidocSignatureSpan"></span>bson
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bson = function () {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.BSON" id="apidoc.element.bson.BSON">
        function <span class="apidocSignatureSpan">bson.</span>BSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BSON = function () {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.BSONRegExp" id="apidoc.element.bson.BSONRegExp">
        function <span class="apidocSignatureSpan">bson.</span>BSONRegExp
        <span class="apidocSignatureSpan">(pattern, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BSONRegExp(pattern, options) {
  if(!(this instanceof BSONRegExp)) return new BSONRegExp();

  // Execute
  this._bsontype = 'BSONRegExp';
  this.pattern = pattern || '';
  this.options = options || '';

  // Validate options
  for(var i = 0; i &lt; this.options.length; i++) {
    if(!(this.options[i] == 'i'
      || this.options[i] == 'm'
      || this.options[i] == 'x'
      || this.options[i] == 'l'
      || this.options[i] == 's'
      || this.options[i] == 'u'
    )) {
      throw new Error('the regular expression options [' + this.options[i] + "] is not supported");
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Binary" id="apidoc.element.bson.Binary">
        function <span class="apidocSignatureSpan">bson.</span>Binary
        <span class="apidocSignatureSpan">(buffer, subType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Binary(buffer, subType) {
  if(!(this instanceof Binary)) return new Binary(buffer, subType);

  this._bsontype = 'Binary';

  if(buffer instanceof Number) {
    this.sub_type = buffer;
    this.position = 0;
  } else {
    this.sub_type = subType == null ? BSON_BINARY_SUBTYPE_DEFAULT : subType;
    this.position = 0;
  }

  if(buffer != null &amp;&amp; !(buffer instanceof Number)) {
    // Only accept Buffer, Uint8Array or Arrays
    if(typeof buffer == 'string') {
      // Different ways of writing the length of the string for the different types
      if(typeof Buffer != 'undefined') {
        this.buffer = new Buffer(buffer);
      } else if(typeof Uint8Array != 'undefined' || (Object.prototype.toString.call(buffer) == '[object Array]')) {
        this.buffer = writeStringToArray(buffer);
      } else {
        throw new Error("only String, Buffer, Uint8Array or Array accepted");
      }
    } else {
      this.buffer = buffer;
    }
    this.position = buffer.length;
  } else {
    if(typeof Buffer != 'undefined') {
      this.buffer =  new Buffer(Binary.BUFFER_SIZE);
    } else if(typeof Uint8Array != 'undefined'){
      this.buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE));
    } else {
      this.buffer = new Array(Binary.BUFFER_SIZE);
    }
    // Set position to start of buffer
    this.position = 0;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Code" id="apidoc.element.bson.Code">
        function <span class="apidocSignatureSpan">bson.</span>Code
        <span class="apidocSignatureSpan">(code, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Code(code, scope) {
  if(!(this instanceof Code)) return new Code(code, scope);
  this._bsontype = 'Code';
  this.code = code;
  this.scope = scope;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.DBRef" id="apidoc.element.bson.DBRef">
        function <span class="apidocSignatureSpan">bson.</span>DBRef
        <span class="apidocSignatureSpan">(namespace, oid, db)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DBRef(namespace, oid, db) {
  if(!(this instanceof DBRef)) return new DBRef(namespace, oid, db);

  this._bsontype = 'DBRef';
  this.namespace = namespace;
  this.oid = oid;
  this.db = db;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Decimal128" id="apidoc.element.bson.Decimal128">
        function <span class="apidocSignatureSpan">bson.</span>Decimal128
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Decimal128 = function (bytes) {
  this._bsontype = 'Decimal128';
  this.bytes = bytes;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Double" id="apidoc.element.bson.Double">
        function <span class="apidocSignatureSpan">bson.</span>Double
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Double(value) {
  if(!(this instanceof Double)) return new Double(value);

  this._bsontype = 'Double';
  this.value = value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Int32" id="apidoc.element.bson.Int32">
        function <span class="apidocSignatureSpan">bson.</span>Int32
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Int32 = function (value) {
  if(!(this instanceof Int32)) return new Int32(value);

  this._bsontype = 'Int32';
  this.value = value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Long" id="apidoc.element.bson.Long">
        function <span class="apidocSignatureSpan">bson.</span>Long
        <span class="apidocSignatureSpan">(low, high)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Long(low, high) {
  if(!(this instanceof Long)) return new Long(low, high);

  this._bsontype = 'Long';
<span class="apidocCodeCommentSpan">  /**
   * @type {number}
   * @ignore
   */
</span>  this.low_ = low | 0;  // force into 32 signed bits.

  /**
   * @type {number}
   * @ignore
   */
  this.high_ = high | 0;  // force into 32 signed bits.
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Map" id="apidoc.element.bson.Map">
        function <span class="apidocSignatureSpan">bson.</span>Map
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Map() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.MaxKey" id="apidoc.element.bson.MaxKey">
        function <span class="apidocSignatureSpan">bson.</span>MaxKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MaxKey() {
  if(!(this instanceof MaxKey)) return new MaxKey();

  this._bsontype = 'MaxKey';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.MinKey" id="apidoc.element.bson.MinKey">
        function <span class="apidocSignatureSpan">bson.</span>MinKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MinKey() {
  if(!(this instanceof MinKey)) return new MinKey();

  this._bsontype = 'MinKey';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.ObjectID" id="apidoc.element.bson.ObjectID">
        function <span class="apidocSignatureSpan">bson.</span>ObjectID
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ObjectID(id) {
  // Duck-typing to support ObjectId from different npm packages
  if(id instanceof ObjectID) return id;
  if(!(this instanceof ObjectID)) return new ObjectID(id);

  this._bsontype = 'ObjectID';

  // The most common usecase (blank id, new objectId instance)
  if(id == null || typeof id == 'number') {
    // Generate a new id
    this.id = this.generate(id);
    // If we are caching the hex string
    if(ObjectID.cacheHexString) this.__id = this.toString('hex');
    // Return the object
    return;
  }

  // Check if the passed in id is valid
  var valid = ObjectID.isValid(id);

  // Throw an error if it's not a valid setup
  if(!valid &amp;&amp; id != null){
    throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
  } else if(valid &amp;&amp; typeof id == 'string' &amp;&amp; id.length == 24 &amp;&amp; hasBufferType) {
    return new ObjectID(new Buffer(id, 'hex'));
  } else if(valid &amp;&amp; typeof id == 'string' &amp;&amp; id.length == 24) {
    return ObjectID.createFromHexString(id);
  } else if(id != null &amp;&amp; id.length === 12) {
    // assume 12 byte string
    this.id = id;
  } else if(id != null &amp;&amp; id.toHexString) {
    // Duck-typing to support ObjectId from different npm packages
    return id;
  } else {
    throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
  }

  if(ObjectID.cacheHexString) this.__id = this.toString('hex');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.ObjectId" id="apidoc.element.bson.ObjectId">
        function <span class="apidocSignatureSpan">bson.</span>ObjectId
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ObjectID(id) {
  // Duck-typing to support ObjectId from different npm packages
  if(id instanceof ObjectID) return id;
  if(!(this instanceof ObjectID)) return new ObjectID(id);

  this._bsontype = 'ObjectID';

  // The most common usecase (blank id, new objectId instance)
  if(id == null || typeof id == 'number') {
    // Generate a new id
    this.id = this.generate(id);
    // If we are caching the hex string
    if(ObjectID.cacheHexString) this.__id = this.toString('hex');
    // Return the object
    return;
  }

  // Check if the passed in id is valid
  var valid = ObjectID.isValid(id);

  // Throw an error if it's not a valid setup
  if(!valid &amp;&amp; id != null){
    throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
  } else if(valid &amp;&amp; typeof id == 'string' &amp;&amp; id.length == 24 &amp;&amp; hasBufferType) {
    return new ObjectID(new Buffer(id, 'hex'));
  } else if(valid &amp;&amp; typeof id == 'string' &amp;&amp; id.length == 24) {
    return ObjectID.createFromHexString(id);
  } else if(id != null &amp;&amp; id.length === 12) {
    // assume 12 byte string
    this.id = id;
  } else if(id != null &amp;&amp; id.toHexString) {
    // Duck-typing to support ObjectId from different npm packages
    return id;
  } else {
    throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
  }

  if(ObjectID.cacheHexString) this.__id = this.toString('hex');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Symbol" id="apidoc.element.bson.Symbol">
        function <span class="apidocSignatureSpan">bson.</span>Symbol
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Symbol(value) {
  if(!(this instanceof Symbol)) return new Symbol(value);
  this._bsontype = 'Symbol';
  this.value = value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Timestamp" id="apidoc.element.bson.Timestamp">
        function <span class="apidocSignatureSpan">bson.</span>Timestamp
        <span class="apidocSignatureSpan">(low, high)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Timestamp(low, high) {
  if(!(this instanceof Timestamp)) return new Timestamp(low, high);
  this._bsontype = 'Timestamp';
<span class="apidocCodeCommentSpan">  /**
   * @type {number}
   * @ignore
   */
</span>  this.low_ = low | 0;  // force into 32 signed bits.

  /**
   * @type {number}
   * @ignore
   */
  this.high_ = high | 0;  // force into 32 signed bits.
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






















































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bson.BSON" id="apidoc.module.bson.BSON">module bson.BSON</a></h1>


    <h2>
        <a href="#apidoc.element.bson.BSON.BSON" id="apidoc.element.bson.BSON.BSON">
        function <span class="apidocSignatureSpan">bson.</span>BSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BSON = function () {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.BSON.BSONRegExp" id="apidoc.element.bson.BSON.BSONRegExp">
        function <span class="apidocSignatureSpan">bson.BSON.</span>BSONRegExp
        <span class="apidocSignatureSpan">(pattern, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BSONRegExp(pattern, options) {
  if(!(this instanceof BSONRegExp)) return new BSONRegExp();

  // Execute
  this._bsontype = 'BSONRegExp';
  this.pattern = pattern || '';
  this.options = options || '';

  // Validate options
  for(var i = 0; i &lt; this.options.length; i++) {
    if(!(this.options[i] == 'i'
      || this.options[i] == 'm'
      || this.options[i] == 'x'
      || this.options[i] == 'l'
      || this.options[i] == 's'
      || this.options[i] == 'u'
    )) {
      throw new Error('the regular expression options [' + this.options[i] + "] is not supported");
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.BSON.Binary" id="apidoc.element.bson.BSON.Binary">
        function <span class="apidocSignatureSpan">bson.BSON.</span>Binary
        <span class="apidocSignatureSpan">(buffer, subType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Binary(buffer, subType) {
  if(!(this instanceof Binary)) return new Binary(buffer, subType);

  this._bsontype = 'Binary';

  if(buffer instanceof Number) {
    this.sub_type = buffer;
    this.position = 0;
  } else {
    this.sub_type = subType == null ? BSON_BINARY_SUBTYPE_DEFAULT : subType;
    this.position = 0;
  }

  if(buffer != null &amp;&amp; !(buffer instanceof Number)) {
    // Only accept Buffer, Uint8Array or Arrays
    if(typeof buffer == 'string') {
      // Different ways of writing the length of the string for the different types
      if(typeof Buffer != 'undefined') {
        this.buffer = new Buffer(buffer);
      } else if(typeof Uint8Array != 'undefined' || (Object.prototype.toString.call(buffer) == '[object Array]')) {
        this.buffer = writeStringToArray(buffer);
      } else {
        throw new Error("only String, Buffer, Uint8Array or Array accepted");
      }
    } else {
      this.buffer = buffer;
    }
    this.position = buffer.length;
  } else {
    if(typeof Buffer != 'undefined') {
      this.buffer =  new Buffer(Binary.BUFFER_SIZE);
    } else if(typeof Uint8Array != 'undefined'){
      this.buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE));
    } else {
      this.buffer = new Array(Binary.BUFFER_SIZE);
    }
    // Set position to start of buffer
    this.position = 0;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.BSON.Code" id="apidoc.element.bson.BSON.Code">
        function <span class="apidocSignatureSpan">bson.BSON.</span>Code
        <span class="apidocSignatureSpan">(code, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Code(code, scope) {
  if(!(this instanceof Code)) return new Code(code, scope);
  this._bsontype = 'Code';
  this.code = code;
  this.scope = scope;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.BSON.DBRef" id="apidoc.element.bson.BSON.DBRef">
        function <span class="apidocSignatureSpan">bson.BSON.</span>DBRef
        <span class="apidocSignatureSpan">(namespace, oid, db)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DBRef(namespace, oid, db) {
  if(!(this instanceof DBRef)) return new DBRef(namespace, oid, db);

  this._bsontype = 'DBRef';
  this.namespace = namespace;
  this.oid = oid;
  this.db = db;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.BSON.Decimal128" id="apidoc.element.bson.BSON.Decimal128">
        function <span class="apidocSignatureSpan">bson.BSON.</span>Decimal128
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Decimal128 = function (bytes) {
  this._bsontype = 'Decimal128';
  this.bytes = bytes;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.BSON.Double" id="apidoc.element.bson.BSON.Double">
        function <span class="apidocSignatureSpan">bson.BSON.</span>Double
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Double(value) {
  if(!(this instanceof Double)) return new Double(value);

  this._bsontype = 'Double';
  this.value = value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.BSON.Int32" id="apidoc.element.bson.BSON.Int32">
        function <span class="apidocSignatureSpan">bson.BSON.</span>Int32
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Int32 = function (value) {
  if(!(this instanceof Int32)) return new Int32(value);

  this._bsontype = 'Int32';
  this.value = value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.BSON.Long" id="apidoc.element.bson.BSON.Long">
        function <span class="apidocSignatureSpan">bson.BSON.</span>Long
        <span class="apidocSignatureSpan">(low, high)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Long(low, high) {
  if(!(this instanceof Long)) return new Long(low, high);

  this._bsontype = 'Long';
<span class="apidocCodeCommentSpan">  /**
   * @type {number}
   * @ignore
   */
</span>  this.low_ = low | 0;  // force into 32 signed bits.

  /**
   * @type {number}
   * @ignore
   */
  this.high_ = high | 0;  // force into 32 signed bits.
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.BSON.Map" id="apidoc.element.bson.BSON.Map">
        function <span class="apidocSignatureSpan">bson.BSON.</span>Map
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Map() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.BSON.MaxKey" id="apidoc.element.bson.BSON.MaxKey">
        function <span class="apidocSignatureSpan">bson.BSON.</span>MaxKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MaxKey() {
  if(!(this instanceof MaxKey)) return new MaxKey();

  this._bsontype = 'MaxKey';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.BSON.MinKey" id="apidoc.element.bson.BSON.MinKey">
        function <span class="apidocSignatureSpan">bson.BSON.</span>MinKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MinKey() {
  if(!(this instanceof MinKey)) return new MinKey();

  this._bsontype = 'MinKey';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.BSON.ObjectID" id="apidoc.element.bson.BSON.ObjectID">
        function <span class="apidocSignatureSpan">bson.BSON.</span>ObjectID
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ObjectID(id) {
  // Duck-typing to support ObjectId from different npm packages
  if(id instanceof ObjectID) return id;
  if(!(this instanceof ObjectID)) return new ObjectID(id);

  this._bsontype = 'ObjectID';

  // The most common usecase (blank id, new objectId instance)
  if(id == null || typeof id == 'number') {
    // Generate a new id
    this.id = this.generate(id);
    // If we are caching the hex string
    if(ObjectID.cacheHexString) this.__id = this.toString('hex');
    // Return the object
    return;
  }

  // Check if the passed in id is valid
  var valid = ObjectID.isValid(id);

  // Throw an error if it's not a valid setup
  if(!valid &amp;&amp; id != null){
    throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
  } else if(valid &amp;&amp; typeof id == 'string' &amp;&amp; id.length == 24 &amp;&amp; hasBufferType) {
    return new ObjectID(new Buffer(id, 'hex'));
  } else if(valid &amp;&amp; typeof id == 'string' &amp;&amp; id.length == 24) {
    return ObjectID.createFromHexString(id);
  } else if(id != null &amp;&amp; id.length === 12) {
    // assume 12 byte string
    this.id = id;
  } else if(id != null &amp;&amp; id.toHexString) {
    // Duck-typing to support ObjectId from different npm packages
    return id;
  } else {
    throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
  }

  if(ObjectID.cacheHexString) this.__id = this.toString('hex');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.BSON.ObjectId" id="apidoc.element.bson.BSON.ObjectId">
        function <span class="apidocSignatureSpan">bson.BSON.</span>ObjectId
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ObjectID(id) {
  // Duck-typing to support ObjectId from different npm packages
  if(id instanceof ObjectID) return id;
  if(!(this instanceof ObjectID)) return new ObjectID(id);

  this._bsontype = 'ObjectID';

  // The most common usecase (blank id, new objectId instance)
  if(id == null || typeof id == 'number') {
    // Generate a new id
    this.id = this.generate(id);
    // If we are caching the hex string
    if(ObjectID.cacheHexString) this.__id = this.toString('hex');
    // Return the object
    return;
  }

  // Check if the passed in id is valid
  var valid = ObjectID.isValid(id);

  // Throw an error if it's not a valid setup
  if(!valid &amp;&amp; id != null){
    throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
  } else if(valid &amp;&amp; typeof id == 'string' &amp;&amp; id.length == 24 &amp;&amp; hasBufferType) {
    return new ObjectID(new Buffer(id, 'hex'));
  } else if(valid &amp;&amp; typeof id == 'string' &amp;&amp; id.length == 24) {
    return ObjectID.createFromHexString(id);
  } else if(id != null &amp;&amp; id.length === 12) {
    // assume 12 byte string
    this.id = id;
  } else if(id != null &amp;&amp; id.toHexString) {
    // Duck-typing to support ObjectId from different npm packages
    return id;
  } else {
    throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
  }

  if(ObjectID.cacheHexString) this.__id = this.toString('hex');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.BSON.Symbol" id="apidoc.element.bson.BSON.Symbol">
        function <span class="apidocSignatureSpan">bson.BSON.</span>Symbol
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Symbol(value) {
  if(!(this instanceof Symbol)) return new Symbol(value);
  this._bsontype = 'Symbol';
  this.value = value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.BSON.Timestamp" id="apidoc.element.bson.BSON.Timestamp">
        function <span class="apidocSignatureSpan">bson.BSON.</span>Timestamp
        <span class="apidocSignatureSpan">(low, high)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Timestamp(low, high) {
  if(!(this instanceof Timestamp)) return new Timestamp(low, high);
  this._bsontype = 'Timestamp';
<span class="apidocCodeCommentSpan">  /**
   * @type {number}
   * @ignore
   */
</span>  this.low_ = low | 0;  // force into 32 signed bits.

  /**
   * @type {number}
   * @ignore
   */
  this.high_ = high | 0;  // force into 32 signed bits.
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






























































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bson.BSON.prototype" id="apidoc.module.bson.BSON.prototype">module bson.BSON.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.bson.BSON.prototype.calculateObjectSize" id="apidoc.element.bson.BSON.prototype.calculateObjectSize">
        function <span class="apidocSignatureSpan">bson.BSON.prototype.</span>calculateObjectSize
        <span class="apidocSignatureSpan">(object, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">calculateObjectSize = function (object, options) {
	options = options || {};

	var serializeFunctions = typeof options.serializeFunctions == 'boolean'
		? options.serializeFunctions : false;
	var ignoreUndefined = typeof options.ignoreUndefined == 'boolean'
		? options.ignoreUndefined : true;

  return calculateObjectSize(object, serializeFunctions, ignoreUndefined);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    * @param {Number} [options.index=0] the index in the buffer where we wish to start serializing into.
    * @return {Number} returns the index pointing to the last written byte in the buffer.

#### BSON.calculateObjectSize

The BSON calculateObjectSize method takes a javascript object and an optional options object and returns the size of the BSON object
.

  * BSON.<span class="apidocCodeKeywordSpan">calculateObjectSize</span>(object, options)
    * @param {Object} object the Javascript object to serialize.
    * @param {Boolean} [options.serializeFunctions=false] serialize the javascript. functions.
    * @param {Boolean} [options.ignoreUndefined=true]
    * @return {Buffer} returns a Buffer instance.

#### BSON.deserialize
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.BSON.prototype.deserialize" id="apidoc.element.bson.BSON.prototype.deserialize">
        function <span class="apidocSignatureSpan">bson.BSON.prototype.</span>deserialize
        <span class="apidocSignatureSpan">(buffer, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deserialize = function (buffer, options) {
  return deserialize(buffer, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    // Serialize document
    var doc = { long: Long.fromNumber(100) }

    // Serialize a document
    var data = bson.serialize(doc)
    // De serialize it again
    var doc_2 = bson.<span class="apidocCodeKeywordSpan">deserialize</span>(data)
  }
&lt;/script&gt;
```

A simple example of how to use BSON in `node.js`:

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.BSON.prototype.deserializeStream" id="apidoc.element.bson.BSON.prototype.deserializeStream">
        function <span class="apidocSignatureSpan">bson.BSON.prototype.</span>deserializeStream
        <span class="apidocSignatureSpan">(data, startIndex, numberOfDocuments, documents, docStartIndex, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deserializeStream = function (data, startIndex, numberOfDocuments, documents, docStartIndex, options) {
  options = options != null ? options : {};
  var index = startIndex;
  // Loop over all documents
  for(var i = 0; i &lt; numberOfDocuments; i++) {
    // Find size of the document
    var size = data[index] | data[index + 1] &lt;&lt; 8 | data[index + 2] &lt;&lt; 16 | data[index + 3] &lt;&lt; 24;
    // Update options with index
    options['index'] = index;
    // Parse the document at this point
    documents[docStartIndex + i] = this.deserialize(data, options);
    // Adjust index by the document size
    index = index + size;
  }

  // Return object containing end index of parsing and list of documents
  return index;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  * @param {Object} [options.bsonRegExp=false] return BSON regular expressions as BSONRegExp instances.
  * @return {Number} returns the next index in the buffer after deserialization **x** numbers of documents.

#### BSON.deserializeStream

The BSON deserializeStream method takes a node.js Buffer, startIndex and allow more control over deserialization of a Buffer containing
 concatenated BSON documents.

* BSON.<span class="apidocCodeKeywordSpan">deserializeStream</span>(buffer, startIndex, numberOfDocuments, documents, docStartIndex
, options)
  * @param {Buffer} buffer the buffer containing the serialized set of BSON documents.
  * @param {Number} startIndex the start index in the data Buffer where the deserialization is to start.
  * @param {Number} numberOfDocuments number of documents to deserialize.
  * @param {Array} documents an array where to store the deserialized documents.
  * @param {Number} docStartIndex the index in the documents array from where to start inserting documents.
  * @param {Object} [options.evalFunctions=false] evaluate functions in the BSON document scoped to the object deserialized.
  * @param {Object} [options.cacheFunctions=false] cache evaluated functions for reuse.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.BSON.prototype.serialize" id="apidoc.element.bson.BSON.prototype.serialize">
        function <span class="apidocSignatureSpan">bson.BSON.prototype.</span>serialize
        <span class="apidocSignatureSpan">(object, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function serialize(object, options) {
	options = options || {};
	// Unpack the options
	var checkKeys = typeof options.checkKeys == 'boolean'
		? options.checkKeys : false;
	var serializeFunctions = typeof options.serializeFunctions == 'boolean'
		? options.serializeFunctions : false;
	var ignoreUndefined = typeof options.ignoreUndefined == 'boolean'
		? options.ignoreUndefined : true;

	// Attempt to serialize
	var serializationIndex = serializer(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, []);
	// Create the final buffer
	var finishedBuffer = new Buffer(serializationIndex);
	// Copy into the finished buffer
	buffer.copy(finishedBuffer, 0, 0, finishedBuffer.length);
	// Return the buffer
	return finishedBuffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // Create a bson parser instance
    var bson = new BSON();

    // Serialize document
    var doc = { long: Long.fromNumber(100) }

    // Serialize a document
    var data = bson.<span class="apidocCodeKeywordSpan">serialize</span>(doc)
    // De serialize it again
    var doc_2 = bson.deserialize(data)
  }
&lt;/script&gt;
```

A simple example of how to use BSON in `node.js`:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.BSON.prototype.serializeWithBufferAndIndex" id="apidoc.element.bson.BSON.prototype.serializeWithBufferAndIndex">
        function <span class="apidocSignatureSpan">bson.BSON.prototype.</span>serializeWithBufferAndIndex
        <span class="apidocSignatureSpan">(object, finalBuffer, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serializeWithBufferAndIndex = function (object, finalBuffer, options) {
	options = options || {};
	// Unpack the options
	var checkKeys = typeof options.checkKeys == 'boolean'
		? options.checkKeys : false;
	var serializeFunctions = typeof options.serializeFunctions == 'boolean'
		? options.serializeFunctions : false;
	var ignoreUndefined = typeof options.ignoreUndefined == 'boolean'
		? options.ignoreUndefined : true;
	var startIndex = typeof options.index == 'number'
		? options.index : 0;

	// Attempt to serialize
	var serializationIndex = serializer(buffer, object, checkKeys, startIndex || 0, 0, serializeFunctions, ignoreUndefined);
	buffer.copy(finalBuffer, startIndex, 0, serializationIndex);

	// Return the index
	return serializationIndex - 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  * @param {Boolean} [options.ignoreUndefined=true]
  * @return {Buffer} returns a Buffer instance.

#### BSON.serializeWithBufferAndIndex

The BSON serializeWithBufferAndIndex method takes an object, a target buffer instance and an optional options object and returns
 the end serialization index in the final buffer.

* BSON.<span class="apidocCodeKeywordSpan">serializeWithBufferAndIndex</span>(object, buffer, options)
  * @param {Object} object the Javascript object to serialize.
  * @param {Buffer} buffer the Buffer you pre-allocated to store the serialized BSON object.
  * @param {Boolean} [options.checkKeys=false] the serializer will check if keys are valid.
  * @param {Boolean} [options.serializeFunctions=false] serialize the javascript functions.
  * @param {Boolean} [options.ignoreUndefined=true] ignore undefined fields.
  * @param {Number} [options.index=0] the index in the buffer where we wish to start serializing into.
  * @return {Number} returns the index pointing to the last written byte in the buffer.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bson.BSONRegExp" id="apidoc.module.bson.BSONRegExp">module bson.BSONRegExp</a></h1>


    <h2>
        <a href="#apidoc.element.bson.BSONRegExp.BSONRegExp" id="apidoc.element.bson.BSONRegExp.BSONRegExp">
        function <span class="apidocSignatureSpan">bson.</span>BSONRegExp
        <span class="apidocSignatureSpan">(pattern, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BSONRegExp(pattern, options) {
  if(!(this instanceof BSONRegExp)) return new BSONRegExp();

  // Execute
  this._bsontype = 'BSONRegExp';
  this.pattern = pattern || '';
  this.options = options || '';

  // Validate options
  for(var i = 0; i &lt; this.options.length; i++) {
    if(!(this.options[i] == 'i'
      || this.options[i] == 'm'
      || this.options[i] == 'x'
      || this.options[i] == 'l'
      || this.options[i] == 's'
      || this.options[i] == 'u'
    )) {
      throw new Error('the regular expression options [' + this.options[i] + "] is not supported");
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bson.Binary" id="apidoc.module.bson.Binary">module bson.Binary</a></h1>


    <h2>
        <a href="#apidoc.element.bson.Binary.Binary" id="apidoc.element.bson.Binary.Binary">
        function <span class="apidocSignatureSpan">bson.</span>Binary
        <span class="apidocSignatureSpan">(buffer, subType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Binary(buffer, subType) {
  if(!(this instanceof Binary)) return new Binary(buffer, subType);

  this._bsontype = 'Binary';

  if(buffer instanceof Number) {
    this.sub_type = buffer;
    this.position = 0;
  } else {
    this.sub_type = subType == null ? BSON_BINARY_SUBTYPE_DEFAULT : subType;
    this.position = 0;
  }

  if(buffer != null &amp;&amp; !(buffer instanceof Number)) {
    // Only accept Buffer, Uint8Array or Arrays
    if(typeof buffer == 'string') {
      // Different ways of writing the length of the string for the different types
      if(typeof Buffer != 'undefined') {
        this.buffer = new Buffer(buffer);
      } else if(typeof Uint8Array != 'undefined' || (Object.prototype.toString.call(buffer) == '[object Array]')) {
        this.buffer = writeStringToArray(buffer);
      } else {
        throw new Error("only String, Buffer, Uint8Array or Array accepted");
      }
    } else {
      this.buffer = buffer;
    }
    this.position = buffer.length;
  } else {
    if(typeof Buffer != 'undefined') {
      this.buffer =  new Buffer(Binary.BUFFER_SIZE);
    } else if(typeof Uint8Array != 'undefined'){
      this.buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE));
    } else {
      this.buffer = new Array(Binary.BUFFER_SIZE);
    }
    // Set position to start of buffer
    this.position = 0;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bson.Binary.prototype" id="apidoc.module.bson.Binary.prototype">module bson.Binary.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.bson.Binary.prototype.length" id="apidoc.element.bson.Binary.prototype.length">
        function <span class="apidocSignatureSpan">bson.Binary.prototype.</span>length
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function length() {
  return this.position;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Binary.prototype.put" id="apidoc.element.bson.Binary.prototype.put">
        function <span class="apidocSignatureSpan">bson.Binary.prototype.</span>put
        <span class="apidocSignatureSpan">(byte_value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function put(byte_value) {
  // If it's a string and a has more than one character throw an error
  if(byte_value['length'] != null &amp;&amp; typeof byte_value != 'number' &amp;&amp; byte_value.length != 1) throw new Error("only accepts single
 character String, Uint8Array or Array");
  if(typeof byte_value != 'number' &amp;&amp; byte_value &lt; 0 || byte_value &gt; 255) throw new Error("only accepts number in a valid unsigned
 byte range 0-255");

  // Decode the byte value once
  var decoded_byte = null;
  if(typeof byte_value == 'string') {
    decoded_byte = byte_value.charCodeAt(0);
  } else if(byte_value['length'] != null) {
    decoded_byte = byte_value[0];
  } else {
    decoded_byte = byte_value;
  }

  if(this.buffer.length &gt; this.position) {
    this.buffer[this.position++] = decoded_byte;
  } else {
    if(typeof Buffer != 'undefined' &amp;&amp; Buffer.isBuffer(this.buffer)) {
      // Create additional overflow buffer
      var buffer = new Buffer(Binary.BUFFER_SIZE + this.buffer.length);
      // Combine the two buffers together
      this.buffer.copy(buffer, 0, 0, this.buffer.length);
      this.buffer = buffer;
      this.buffer[this.position++] = decoded_byte;
    } else {
      var buffer = null;
      // Create a new buffer (typed or normal array)
      if(Object.prototype.toString.call(this.buffer) == '[object Uint8Array]') {
        buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE + this.buffer.length));
      } else {
        buffer = new Array(Binary.BUFFER_SIZE + this.buffer.length);
      }

      // We need to copy all the content to the new array
      for(var i = 0; i &lt; this.buffer.length; i++) {
        buffer[i] = this.buffer[i];
      }

      // Reassign the buffer
      this.buffer = buffer;
      // Write the byte
      this.buffer[this.position++] = decoded_byte;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Binary.prototype.read" id="apidoc.element.bson.Binary.prototype.read">
        function <span class="apidocSignatureSpan">bson.Binary.prototype.</span>read
        <span class="apidocSignatureSpan">(position, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function read(position, length) {
  length = length &amp;&amp; length &gt; 0
    ? length
    : this.position;

  // Let's return the data based on the type we have
  if(this.buffer['slice']) {
    return this.buffer.slice(position, position + length);
  } else {
    // Create a buffer to keep the result
    var buffer = typeof Uint8Array != 'undefined' ? new Uint8Array(new ArrayBuffer(length)) : new Array(length);
    for(var i = 0; i &lt; length; i++) {
      buffer[i] = this.buffer[position++];
    }
  }
  // Return the buffer
  return buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Binary.prototype.toJSON" id="apidoc.element.bson.Binary.prototype.toJSON">
        function <span class="apidocSignatureSpan">bson.Binary.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  return this.buffer != null ? this.buffer.toString('base64') : '';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

	'use strict';
	var $export     = __webpack_require__(8)
	  , toObject    = __webpack_require__(58)
	  , toPrimitive = __webpack_require__(16);

	$export($export.P + $export.F * __webpack_require__(7)(function(){
	  return new Date(NaN).<span class="apidocCodeKeywordSpan">toJSON</span>() !== null || Date.prototype.toJSON.call({toISOString:
function(){ return 1; }}) !== 1;
	}), 'Date', {
	  toJSON: function toJSON(key){
	    var O  = toObject(this)
	      , pv = toPrimitive(O);
	    return typeof pv == 'number' &amp;&amp; !isFinite(pv) ? null : O.toISOString();
	  }
	});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Binary.prototype.toString" id="apidoc.element.bson.Binary.prototype.toString">
        function <span class="apidocSignatureSpan">bson.Binary.prototype.</span>toString
        <span class="apidocSignatureSpan">(format)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function (format) {
  return this.buffer != null ? this.buffer.slice(0, this.position).toString(format) : '';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/***/ },
/* 19 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).<span class="apidocCodeKeywordSpan
">toString</span>(36));
	};

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Binary.prototype.value" id="apidoc.element.bson.Binary.prototype.value">
        function <span class="apidocSignatureSpan">bson.Binary.prototype.</span>value
        <span class="apidocSignatureSpan">(asRaw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function value(asRaw) {
  asRaw = asRaw == null ? false : asRaw;

  // Optimize to serialize for the situation where the data == size of buffer
  if(asRaw &amp;&amp; typeof Buffer != 'undefined' &amp;&amp; Buffer.isBuffer(this.buffer) &amp;&amp; this.buffer.length == this.position)
    return this.buffer;

  // If it's a node.js buffer object
  if(typeof Buffer != 'undefined' &amp;&amp; Buffer.isBuffer(this.buffer)) {
    return asRaw ? this.buffer.slice(0, this.position) : this.buffer.toString('binary', 0, this.position);
  } else {
    if(asRaw) {
      // we support the slice command use it
      if(this.buffer['slice'] != null) {
        return this.buffer.slice(0, this.position);
      } else {
        // Create a new buffer to copy content to
        var newBuffer = Object.prototype.toString.call(this.buffer) == '[object Uint8Array]' ? new Uint8Array(new ArrayBuffer(this
.position)) : new Array(this.position);
        // Copy content
        for(var i = 0; i &lt; this.position; i++) {
          newBuffer[i] = this.buffer[i];
        }
        // Return the buffer
        return newBuffer;
      }
    } else {
      return convertArraytoUtf8BinaryString(this.buffer, 0, this.position);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
buffer[index++] = BSON.BSON_DATA_BINARY;
// Number of written bytes
var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
// Encode the name
index = index + numberOfWrittenBytes;
buffer[index++] = 0;
// Extract the buffer
var data = value.<span class="apidocCodeKeywordSpan">value</span>(true);
// Calculate size
var size = value.position;
// Add the deprecated 02 type 4 bytes of size to total
if(value.sub_type == Binary.SUBTYPE_BYTE_ARRAY) size = size + 4;
// Write the size of the string to buffer
buffer[index++] = size &amp; 0xff;
buffer[index++] = (size &gt;&gt; 8) &amp; 0xff;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Binary.prototype.write" id="apidoc.element.bson.Binary.prototype.write">
        function <span class="apidocSignatureSpan">bson.Binary.prototype.</span>write
        <span class="apidocSignatureSpan">(string, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function write(string, offset) {
  offset = typeof offset == 'number' ? offset : this.position;

  // If the buffer is to small let's extend the buffer
  if(this.buffer.length &lt; offset + string.length) {
    var buffer = null;
    // If we are in node.js
    if(typeof Buffer != 'undefined' &amp;&amp; Buffer.isBuffer(this.buffer)) {
      buffer = new Buffer(this.buffer.length + string.length);
      this.buffer.copy(buffer, 0, 0, this.buffer.length);
    } else if(Object.prototype.toString.call(this.buffer) == '[object Uint8Array]') {
      // Create a new buffer
      buffer = new Uint8Array(new ArrayBuffer(this.buffer.length + string.length))
      // Copy the content
      for(var i = 0; i &lt; this.position; i++) {
        buffer[i] = this.buffer[i];
      }
    }

    // Assign the new buffer
    this.buffer = buffer;
  }

  if(typeof Buffer != 'undefined' &amp;&amp; Buffer.isBuffer(string) &amp;&amp; Buffer.isBuffer(this.buffer)) {
    string.copy(this.buffer, offset, 0, string.length);
    this.position = (offset + string.length) &gt; this.position ? (offset + string.length) : this.position;
    // offset = string.length
  } else if(typeof Buffer != 'undefined' &amp;&amp; typeof string == 'string' &amp;&amp; Buffer.isBuffer(this.buffer)) {
    this.buffer.write(string, offset, 'binary');
    this.position = (offset + string.length) &gt; this.position ? (offset + string.length) : this.position;
    // offset = string.length;
  } else if(Object.prototype.toString.call(string) == '[object Uint8Array]'
    || Object.prototype.toString.call(string) == '[object Array]' &amp;&amp; typeof string != 'string') {
    for(var i = 0; i &lt; string.length; i++) {
      this.buffer[offset++] = string[i];
    }

    this.position = offset &gt; this.position ? offset : this.position;
  } else if(typeof string == 'string') {
    for(var i = 0; i &lt; string.length; i++) {
      this.buffer[offset++] = string.charCodeAt(i);
    }

    this.position = offset &gt; this.position ? offset : this.position;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	  iframe.style.display = 'none';
	  __webpack_require__(48).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.<span class="apidocCodeKeywordSpan">write</span>(lt + 'script' + gt + 'document.F=Object' +
lt + '/script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};

	module.exports = Object.create || function create(O, Properties){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bson.Code" id="apidoc.module.bson.Code">module bson.Code</a></h1>


    <h2>
        <a href="#apidoc.element.bson.Code.Code" id="apidoc.element.bson.Code.Code">
        function <span class="apidocSignatureSpan">bson.</span>Code
        <span class="apidocSignatureSpan">(code, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Code(code, scope) {
  if(!(this instanceof Code)) return new Code(code, scope);
  this._bsontype = 'Code';
  this.code = code;
  this.scope = scope;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bson.Code.prototype" id="apidoc.module.bson.Code.prototype">module bson.Code.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.bson.Code.prototype.toJSON" id="apidoc.element.bson.Code.prototype.toJSON">
        function <span class="apidocSignatureSpan">bson.Code.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  return {scope:this.scope, code:this.code};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

	'use strict';
	var $export     = __webpack_require__(8)
	  , toObject    = __webpack_require__(58)
	  , toPrimitive = __webpack_require__(16);

	$export($export.P + $export.F * __webpack_require__(7)(function(){
	  return new Date(NaN).<span class="apidocCodeKeywordSpan">toJSON</span>() !== null || Date.prototype.toJSON.call({toISOString:
function(){ return 1; }}) !== 1;
	}), 'Date', {
	  toJSON: function toJSON(key){
	    var O  = toObject(this)
	      , pv = toPrimitive(O);
	    return typeof pv == 'number' &amp;&amp; !isFinite(pv) ? null : O.toISOString();
	  }
	});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bson.DBRef" id="apidoc.module.bson.DBRef">module bson.DBRef</a></h1>


    <h2>
        <a href="#apidoc.element.bson.DBRef.DBRef" id="apidoc.element.bson.DBRef.DBRef">
        function <span class="apidocSignatureSpan">bson.</span>DBRef
        <span class="apidocSignatureSpan">(namespace, oid, db)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DBRef(namespace, oid, db) {
  if(!(this instanceof DBRef)) return new DBRef(namespace, oid, db);

  this._bsontype = 'DBRef';
  this.namespace = namespace;
  this.oid = oid;
  this.db = db;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bson.DBRef.prototype" id="apidoc.module.bson.DBRef.prototype">module bson.DBRef.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.bson.DBRef.prototype.toJSON" id="apidoc.element.bson.DBRef.prototype.toJSON">
        function <span class="apidocSignatureSpan">bson.DBRef.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  return {
    '$ref':this.namespace,
    '$id':this.oid,
    '$db':this.db == null ? '' : this.db
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

	'use strict';
	var $export     = __webpack_require__(8)
	  , toObject    = __webpack_require__(58)
	  , toPrimitive = __webpack_require__(16);

	$export($export.P + $export.F * __webpack_require__(7)(function(){
	  return new Date(NaN).<span class="apidocCodeKeywordSpan">toJSON</span>() !== null || Date.prototype.toJSON.call({toISOString:
function(){ return 1; }}) !== 1;
	}), 'Date', {
	  toJSON: function toJSON(key){
	    var O  = toObject(this)
	      , pv = toPrimitive(O);
	    return typeof pv == 'number' &amp;&amp; !isFinite(pv) ? null : O.toISOString();
	  }
	});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bson.Decimal128" id="apidoc.module.bson.Decimal128">module bson.Decimal128</a></h1>


    <h2>
        <a href="#apidoc.element.bson.Decimal128.Decimal128" id="apidoc.element.bson.Decimal128.Decimal128">
        function <span class="apidocSignatureSpan">bson.</span>Decimal128
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Decimal128 = function (bytes) {
  this._bsontype = 'Decimal128';
  this.bytes = bytes;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Decimal128.fromString" id="apidoc.element.bson.Decimal128.fromString">
        function <span class="apidocSignatureSpan">bson.Decimal128.</span>fromString
        <span class="apidocSignatureSpan">(string)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromString = function (string) {
  // Parse state tracking
  var isNegative = false;
  var sawRadix = false;
  var foundNonZero = false;

  // Total number of significant digits (no leading or trailing zero)
  var significantDigits = 0;
  // Total number of significand digits read
  var nDigitsRead = 0;
  // Total number of digits (no leading zeros)
  var nDigits = 0;
  // The number of the digits after radix
  var radixPosition = 0;
  // The index of the first non-zero in *str*
  var firstNonZero = 0;

  // Digits Array
  var digits = [0];
  // The number of digits in digits
  var nDigitsStored = 0;
  // Insertion pointer for digits
  var digitsInsert = 0;
  // The index of the first non-zero digit
  var firstDigit = 0;
  // The index of the last digit
  var lastDigit = 0;

  // Exponent
  var exponent = 0;
  // loop index over array
  var i = 0;
  // The high 17 digits of the significand
  var significandHigh = [0, 0];
  // The low 17 digits of the significand
  var significandLow = [0, 0];
  // The biased exponent
  var biasedExponent = 0;

  // Read index
  var index = 0;

  // Trim the string
  string = string.trim();

  // Results
  var stringMatch = string.match(PARSE_STRING_REGEXP);
  var infMatch = string.match(PARSE_INF_REGEXP);
  var nanMatch = string.match(PARSE_NAN_REGEXP);

  // Validate the string
  if(!stringMatch
    &amp;&amp; ! infMatch
    &amp;&amp; ! nanMatch || string.length == 0) {
      throw new Error("" + string + " not a valid Decimal128 string");
  }

  // Check if we have an illegal exponent format
  if(stringMatch &amp;&amp; stringMatch[4] &amp;&amp; stringMatch[2] === undefined) {
    throw new Error("" + string + " not a valid Decimal128 string");
  }

  // Get the negative or positive sign
  if(string[index] == '+' || string[index] == '-') {
    isNegative = string[index++] == '-';
  }

  // Check if user passed Infinity or NaN
  if(!isDigit(string[index]) &amp;&amp; string[index] != '.') {
    if(string[index] == 'i' || string[index] == 'I') {
      return new Decimal128(new Buffer(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
    } else if(string[index] == 'N') {
      return new Decimal128(new Buffer(NAN_BUFFER));
    }
  }

  // Read all the digits
  while(isDigit(string[index]) || string[index] == '.') {
    if(string[index] == '.') {
      if(sawRadix) {
        return new Decimal128(new Buffer(NAN_BUFFER));
      }

      sawRadix = true;
      index = index + 1;
      continue;
    }

    if(nDigitsStored &lt; 34) {
      if(string[index] != '0' || foundNonZero) {
        if(!foundNonZero) {
          firstNonZero = nDigitsRead;
        }

        foundNonZero = true;

        // Only store 34 digits
        digits[digitsInsert++] = parseInt(string[index], 10);
        nDigitsStored = nDigitsStored + 1;
      }
    }

    if(foundNonZero) {
      nDigits = nDigits + 1;
    }

    if(sawRadix) {
      radixPosition = radixPosition + 1;
    }

    nDigitsRead = nDigitsRead + 1;
    index = index + 1;
  }

  if(sawRadix &amp;&amp; !nDigitsRead) {
    throw new Error("" + string + " not a valid Decimal128 string");
  }

  // Read exponent if exists
  if(string[index] == 'e' || string[index] == 'E') {
    // Read exponent digits
    var match = string.substr(++index).match(EXPONENT_REGEX);

    // No digits read
    if(!match || !match[2]) {
      return new Decimal128(new Buffer(NAN_BUFFER));
    }

    // Get exponent
    exponent = parseInt(match[0], 10);

    // Adjust the index
    index = index + match[0].length;
  }

  // Return not a number
  if(string[index]) {
    return new Decimal128(new Buffer(NAN_BUFFER));
  }

  // Done reading input
  // Find first non-zero digit in digits
  firstDigit = 0;

  if(!nDigitsStored) {
    firstDigit = 0;
    lastDigit = 0;
    digits[0] = 0;
    nDigits = 1;
    nDigitsStored = 1;
    significantDigits = 0;
  } else {
    lastDigit = nDigitsStored - 1;
    significantDigits = nDigits;

    if(exponent != 0 &amp;&amp; significantDigits != 1) {
      while(string[firstNonZero + significantDigits - 1] == '0') {
        significantDigits = significantDigits - 1;
      }
    }
  }

  // Normalization of ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  for(; dIdx &lt;= lastDigit; dIdx++) {
    significandLow = significandLow.multiply(Long.fromNumber(10));
    significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));
  }
}

var significand = multiply64x2(significandHigh, Long.<span class="apidocCodeKeywordSpan">fromString</span>("100000000000000000
"));

significand.low = significand.low.add(significandLow);

if(lessThan(significand.low, significandLow)) {
  significand.high = significand.high.add(Long.fromNumber(1));
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bson.Decimal128.prototype" id="apidoc.module.bson.Decimal128.prototype">module bson.Decimal128.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.bson.Decimal128.prototype.toJSON" id="apidoc.element.bson.Decimal128.prototype.toJSON">
        function <span class="apidocSignatureSpan">bson.Decimal128.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  return { "$numberDecimal": this.toString() };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

	'use strict';
	var $export     = __webpack_require__(8)
	  , toObject    = __webpack_require__(58)
	  , toPrimitive = __webpack_require__(16);

	$export($export.P + $export.F * __webpack_require__(7)(function(){
	  return new Date(NaN).<span class="apidocCodeKeywordSpan">toJSON</span>() !== null || Date.prototype.toJSON.call({toISOString:
function(){ return 1; }}) !== 1;
	}), 'Date', {
	  toJSON: function toJSON(key){
	    var O  = toObject(this)
	      , pv = toPrimitive(O);
	    return typeof pv == 'number' &amp;&amp; !isFinite(pv) ? null : O.toISOString();
	  }
	});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Decimal128.prototype.toString" id="apidoc.element.bson.Decimal128.prototype.toString">
        function <span class="apidocSignatureSpan">bson.Decimal128.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  // Note: bits in this routine are referred to starting at 0,
  // from the sign bit, towards the coefficient.

  // bits 0 - 31
  var high;
  // bits 32 - 63
  var midh;
  // bits 64 - 95
  var midl;
  // bits 96 - 127
  var low;
  // bits 1 - 5
  var combination;
  // decoded biased exponent (14 bits)
  var biased_exponent;
  // the number of significand digits
  var significand_digits = 0;
  // the base-10 digits in the significand
  var significand = new Array(36);
  for(var i = 0; i &lt; significand.length; i++) significand[i] = 0;
  // read pointer into significand
  var index = 0;

  // unbiased exponent
  var exponent;
  // the exponent if scientific notation is used
  var scientific_exponent;

  // true if the number is zero
  var is_zero = false;

  // the most signifcant significand bits (50-46)
  var significand_msb;
  // temporary storage for significand decoding
  var significand128 = {parts: new Array(4)};
  // indexing variables
  var i;
  var j, k;

  // Output string
  var string = [];

  // Unpack index
  var index = 0;

  // Buffer reference
  var buffer = this.bytes;

  // Unpack the low 64bits into a long
  low = buffer[index++] | buffer[index++] &lt;&lt; 8 | buffer[index++] &lt;&lt; 16 | buffer[index++] &lt;&lt; 24;
  midl = buffer[index++] | buffer[index++] &lt;&lt; 8 | buffer[index++] &lt;&lt; 16 | buffer[index++] &lt;&lt; 24;

  // Unpack the high 64bits into a long
  midh = buffer[index++] | buffer[index++] &lt;&lt; 8 | buffer[index++] &lt;&lt; 16 | buffer[index++] &lt;&lt; 24;
  high = buffer[index++] | buffer[index++] &lt;&lt; 8 | buffer[index++] &lt;&lt; 16 | buffer[index++] &lt;&lt; 24;

  // Unpack index
  var index = 0;

  // Create the state of the decimal
  var dec = {
    low: new Long(low, midl),
    high: new Long(midh, high) };

  if(dec.high.lessThan(Long.ZERO)) {
    string.push('-');
  }

  // Decode combination field and exponent
  combination = (high &gt;&gt; 26) &amp; COMBINATION_MASK;

  if((combination &gt;&gt; 3) == 3) {
    // Check for 'special' values
    if(combination == COMBINATION_INFINITY) {
      return string.join('') + "Infinity";
    } else if(combination == COMBINATION_NAN) {
      return "NaN";
    } else {
      biased_exponent = (high &gt;&gt; 15) &amp; EXPONENT_MASK;
      significand_msb = 0x08 + ((high &gt;&gt; 14) &amp; 0x01);
    }
  } else {
    significand_msb = (high &gt;&gt; 14) &amp; 0x07;
    biased_exponent = (high &gt;&gt; 17) &amp; EXPONENT_MASK;
  }

  exponent = biased_exponent - EXPONENT_BIAS;

  // Create string of significand digits

  // Convert the 114-bit binary number represented by
  // (significand_high, significand_low) to at most 34 decimal
  // digits through modulo and division.
  significand128.parts[0] = (high &amp; 0x3fff) + ((significand_msb &amp; 0xf) &lt;&lt; 14);
  significand128.parts[1] = midh;
  significand128.parts[2] = midl;
  significand128.parts[3] = low;

  if(significand128.parts[0] == 0 &amp;&amp; significand128.parts[1] == 0
    &amp;&amp; significand128.parts[2] == 0 &amp;&amp; significand128.parts[3] == 0) {
      is_zero = true;
  } else {
    for(var k = 3; k &gt;= 0; k--) {
      var least_digits = 0;
      // Peform the divide
      var result = divideu128(significand128);
      significand128 = result.quotient;
      least_digits = result.rem.low_;

      // We now have the 9 least significant digits (in base 2).
      // Convert and output to string.
      if(!least_digits) continue;

      for(var j = 8; j &gt;= 0; j--) {
        // significand[k * 9 + j] = Math.round(least_digits % 10);
        significand[k * 9 + j] = least_digits % 10;
        // least_digits = Math.round(least_digits / 10);
        least_digits = Math.floor(least_digits / 10);
      }
    }
  }

  // Output format options:
  // Scientific - [-]d.dddE(+/-)dd or [-]dE(+/-)dd
  // Regular    - ddd.ddd

  if(is_zero) {
    significand_digits = 1;
    significand[index] = 0;
  } else {
    significand_digits = 36;
    var i = 0;

    while(!significand[index]) {
      i++;
      significand_digits = significand_digits - 1;
      index = index + 1;
    }
  }

  scientific_exponent = significand_digits - 1 + exponent;

  // The scientific exponent checks are dictated by the string conversion
  // ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/***/ },
/* 19 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).<span class="apidocCodeKeywordSpan
">toString</span>(36));
	};

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bson.Double" id="apidoc.module.bson.Double">module bson.Double</a></h1>


    <h2>
        <a href="#apidoc.element.bson.Double.Double" id="apidoc.element.bson.Double.Double">
        function <span class="apidocSignatureSpan">bson.</span>Double
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Double(value) {
  if(!(this instanceof Double)) return new Double(value);

  this._bsontype = 'Double';
  this.value = value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bson.Double.prototype" id="apidoc.module.bson.Double.prototype">module bson.Double.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.bson.Double.prototype.toJSON" id="apidoc.element.bson.Double.prototype.toJSON">
        function <span class="apidocSignatureSpan">bson.Double.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  return this.value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

	'use strict';
	var $export     = __webpack_require__(8)
	  , toObject    = __webpack_require__(58)
	  , toPrimitive = __webpack_require__(16);

	$export($export.P + $export.F * __webpack_require__(7)(function(){
	  return new Date(NaN).<span class="apidocCodeKeywordSpan">toJSON</span>() !== null || Date.prototype.toJSON.call({toISOString:
function(){ return 1; }}) !== 1;
	}), 'Date', {
	  toJSON: function toJSON(key){
	    var O  = toObject(this)
	      , pv = toPrimitive(O);
	    return typeof pv == 'number' &amp;&amp; !isFinite(pv) ? null : O.toISOString();
	  }
	});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Double.prototype.valueOf" id="apidoc.element.bson.Double.prototype.valueOf">
        function <span class="apidocSignatureSpan">bson.Double.prototype.</span>valueOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">valueOf = function () {
  return this.value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bson.Int32" id="apidoc.module.bson.Int32">module bson.Int32</a></h1>


    <h2>
        <a href="#apidoc.element.bson.Int32.Int32" id="apidoc.element.bson.Int32.Int32">
        function <span class="apidocSignatureSpan">bson.</span>Int32
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Int32 = function (value) {
  if(!(this instanceof Int32)) return new Int32(value);

  this._bsontype = 'Int32';
  this.value = value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bson.Int32.prototype" id="apidoc.module.bson.Int32.prototype">module bson.Int32.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.bson.Int32.prototype.toJSON" id="apidoc.element.bson.Int32.prototype.toJSON">
        function <span class="apidocSignatureSpan">bson.Int32.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  return this.value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

	'use strict';
	var $export     = __webpack_require__(8)
	  , toObject    = __webpack_require__(58)
	  , toPrimitive = __webpack_require__(16);

	$export($export.P + $export.F * __webpack_require__(7)(function(){
	  return new Date(NaN).<span class="apidocCodeKeywordSpan">toJSON</span>() !== null || Date.prototype.toJSON.call({toISOString:
function(){ return 1; }}) !== 1;
	}), 'Date', {
	  toJSON: function toJSON(key){
	    var O  = toObject(this)
	      , pv = toPrimitive(O);
	    return typeof pv == 'number' &amp;&amp; !isFinite(pv) ? null : O.toISOString();
	  }
	});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Int32.prototype.valueOf" id="apidoc.element.bson.Int32.prototype.valueOf">
        function <span class="apidocSignatureSpan">bson.Int32.prototype.</span>valueOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">valueOf = function () {
  return this.value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bson.Long" id="apidoc.module.bson.Long">module bson.Long</a></h1>


    <h2>
        <a href="#apidoc.element.bson.Long.Long" id="apidoc.element.bson.Long.Long">
        function <span class="apidocSignatureSpan">bson.</span>Long
        <span class="apidocSignatureSpan">(low, high)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Long(low, high) {
  if(!(this instanceof Long)) return new Long(low, high);

  this._bsontype = 'Long';
<span class="apidocCodeCommentSpan">  /**
   * @type {number}
   * @ignore
   */
</span>  this.low_ = low | 0;  // force into 32 signed bits.

  /**
   * @type {number}
   * @ignore
   */
  this.high_ = high | 0;  // force into 32 signed bits.
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Long.fromBits" id="apidoc.element.bson.Long.fromBits">
        function <span class="apidocSignatureSpan">bson.Long.</span>fromBits
        <span class="apidocSignatureSpan">(lowBits, highBits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromBits = function (lowBits, highBits) {
  return new Long(lowBits, highBits);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 c32 += c16 &gt;&gt;&gt; 16;
 c16 &amp;= 0xFFFF;
 c32 += a32 + b32;
 c48 += c32 &gt;&gt;&gt; 16;
 c32 &amp;= 0xFFFF;
 c48 += a48 + b48;
 c48 &amp;= 0xFFFF;
 return Long.<span class="apidocCodeKeywordSpan">fromBits</span>((c16 &lt;&lt; 16) | c00, (c48 &lt;&lt; 16) | c32);
};

/**
* Returns the difference of this and the given Long.
*
* @method
* @param {Long} other Long to subtract from this.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Long.fromInt" id="apidoc.element.bson.Long.fromInt">
        function <span class="apidocSignatureSpan">bson.Long.</span>fromInt
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromInt = function (value) {
  if (-128 &lt;= value &amp;&amp; value &lt; 128) {
    var cachedObj = Long.INT_CACHE_[value];
    if (cachedObj) {
      return cachedObj;
    }
  }

  var obj = new Long(value | 0, value &lt; 0 ? -1 : 0);
  if (-128 &lt;= value &amp;&amp; value &lt; 128) {
    Long.INT_CACHE_[value] = obj;
  }
  return obj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * @type {number}
 * @ignore
 */
Long.TWO_PWR_63_DBL_ = Long.TWO_PWR_64_DBL_ / 2;

/** @type {Long} */
Long.ZERO = Long.<span class="apidocCodeKeywordSpan">fromInt</span>(0);

/** @type {Long} */
Long.ONE = Long.fromInt(1);

/** @type {Long} */
Long.NEG_ONE = Long.fromInt(-1);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Long.fromNumber" id="apidoc.element.bson.Long.fromNumber">
        function <span class="apidocSignatureSpan">bson.Long.</span>fromNumber
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromNumber = function (value) {
  if (isNaN(value) || !isFinite(value)) {
    return Long.ZERO;
  } else if (value &lt;= -Long.TWO_PWR_63_DBL_) {
    return Long.MIN_VALUE;
  } else if (value + 1 &gt;= Long.TWO_PWR_63_DBL_) {
    return Long.MAX_VALUE;
  } else if (value &lt; 0) {
    return Long.fromNumber(-value).negate();
  } else {
    return new Long(
               (value % Long.TWO_PWR_32_DBL_) | 0,
               (value / Long.TWO_PWR_32_DBL_) | 0);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  function start() {
    // Get the Long type
    var Long = BSON.Long;
    // Create a bson parser instance
    var bson = new BSON();

    // Serialize document
    var doc = { long: Long.<span class="apidocCodeKeywordSpan">fromNumber</span>(100) }

    // Serialize a document
    var data = bson.serialize(doc)
    // De serialize it again
    var doc_2 = bson.deserialize(data)
  }
&lt;/script&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Long.fromString" id="apidoc.element.bson.Long.fromString">
        function <span class="apidocSignatureSpan">bson.Long.</span>fromString
        <span class="apidocSignatureSpan">(str, opt_radix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromString = function (str, opt_radix) {
  if (str.length == 0) {
    throw Error('number format error: empty string');
  }

  var radix = opt_radix || 10;
  if (radix &lt; 2 || 36 &lt; radix) {
    throw Error('radix out of range: ' + radix);
  }

  if (str.charAt(0) == '-') {
    return Long.fromString(str.substring(1), radix).negate();
  } else if (str.indexOf('-') &gt;= 0) {
    throw Error('number format error: interior "-" character: ' + str);
  }

  // Do several (8) digits each time through the loop, so as to
  // minimize the calls to the very expensive emulated div.
  var radixToPower = Long.fromNumber(Math.pow(radix, 8));

  var result = Long.ZERO;
  for (var i = 0; i &lt; str.length; i += 8) {
    var size = Math.min(8, str.length - i);
    var value = parseInt(str.substring(i, i + size), radix);
    if (size &lt; 8) {
      var power = Long.fromNumber(Math.pow(radix, size));
      result = result.multiply(power).add(Long.fromNumber(value));
    } else {
      result = result.multiply(radixToPower);
      result = result.add(Long.fromNumber(value));
    }
  }
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  for(; dIdx &lt;= lastDigit; dIdx++) {
    significandLow = significandLow.multiply(Long.fromNumber(10));
    significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));
  }
}

var significand = multiply64x2(significandHigh, Long.<span class="apidocCodeKeywordSpan">fromString</span>("100000000000000000
"));

significand.low = significand.low.add(significandLow);

if(lessThan(significand.low, significandLow)) {
  significand.high = significand.high.add(Long.fromNumber(1));
}
...</pre></li>
    </ul>






























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bson.Long.prototype" id="apidoc.module.bson.Long.prototype">module bson.Long.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.bson.Long.prototype.add" id="apidoc.element.bson.Long.prototype.add">
        function <span class="apidocSignatureSpan">bson.Long.prototype.</span>add
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (other) {
  // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

  var a48 = this.high_ &gt;&gt;&gt; 16;
  var a32 = this.high_ &amp; 0xFFFF;
  var a16 = this.low_ &gt;&gt;&gt; 16;
  var a00 = this.low_ &amp; 0xFFFF;

  var b48 = other.high_ &gt;&gt;&gt; 16;
  var b32 = other.high_ &amp; 0xFFFF;
  var b16 = other.low_ &gt;&gt;&gt; 16;
  var b00 = other.low_ &amp; 0xFFFF;

  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 + b00;
  c16 += c00 &gt;&gt;&gt; 16;
  c00 &amp;= 0xFFFF;
  c16 += a16 + b16;
  c32 += c16 &gt;&gt;&gt; 16;
  c16 &amp;= 0xFFFF;
  c32 += a32 + b32;
  c48 += c32 &gt;&gt;&gt; 16;
  c32 &amp;= 0xFFFF;
  c48 += a48 + b48;
  c48 &amp;= 0xFFFF;
  return Long.fromBits((c16 &lt;&lt; 16) | c00, (c48 &lt;&lt; 16) | c32);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	'use strict';
	var strong = __webpack_require__(212);

	// 23.2 Set Objects
	module.exports = __webpack_require__(213)('Set', function(get){
	  return function Set(){ return get(this, arguments.length &gt; 0 ? arguments[0] : undefined); };
	}, {
	  // 23.2.3.1 Set.prototype.<span class="apidocCodeKeywordSpan">add</span>(value)
	  add: function add(value){
	    return strong.def(this, value = value === 0 ? 0 : value, value);
	  }
	}, strong);

/***/ },
/* 215 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Long.prototype.and" id="apidoc.element.bson.Long.prototype.and">
        function <span class="apidocSignatureSpan">bson.Long.prototype.</span>and
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">and = function (other) {
  return Long.fromBits(this.low_ &amp; other.low_, this.high_ &amp; other.high_);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// Biased exponent
var biasedExponent = (exponent + EXPONENT_BIAS);
var dec = { low: Long.fromNumber(0), high: Long.fromNumber(0) };

// Encode combination, exponent, and significand.
if(significand.high.shiftRightUnsigned(49).<span class="apidocCodeKeywordSpan">and</span>(Long.fromNumber(1)).equals(Long.fromNumber
)) {
  // Encode '11' into bits 1 to 3
  dec.high = dec.high.or(Long.fromNumber(0x3).shiftLeft(61));
  dec.high = dec.high.or(Long.fromNumber(biasedExponent).and(Long.fromNumber(0x3fff).shiftLeft(47)));
  dec.high = dec.high.or(significand.high.and(Long.fromNumber(0x7fffffffffff)));
} else {
  dec.high = dec.high.or(Long.fromNumber(biasedExponent &amp; 0x3fff).shiftLeft(49));
  dec.high = dec.high.or(significand.high.and(Long.fromNumber(0x1ffffffffffff)));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Long.prototype.compare" id="apidoc.element.bson.Long.prototype.compare">
        function <span class="apidocSignatureSpan">bson.Long.prototype.</span>compare
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compare = function (other) {
  if (this.equals(other)) {
    return 0;
  }

  var thisNeg = this.isNegative();
  var otherNeg = other.isNegative();
  if (thisNeg &amp;&amp; !otherNeg) {
    return -1;
  }
  if (!thisNeg &amp;&amp; otherNeg) {
    return 1;
  }

  // at this point, the signs are the same, so subtraction will not overflow
  if (this.subtract(other).isNegative()) {
    return -1;
  } else {
    return 1;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Return whether this Long is less than the other.
*
* @method
* @param {Long} other Long to compare against.
* @return {boolean} whether this Long is less than the other.
*/
Long.prototype.lessThan = function(other) {
 return this.<span class="apidocCodeKeywordSpan">compare</span>(other) &lt; 0;
};

/**
* Return whether this Long is less than or equal to the other.
*
* @method
* @param {Long} other Long to compare against.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Long.prototype.div" id="apidoc.element.bson.Long.prototype.div">
        function <span class="apidocSignatureSpan">bson.Long.prototype.</span>div
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">div = function (other) {
  if (other.isZero()) {
    throw Error('division by zero');
  } else if (this.isZero()) {
    return Long.ZERO;
  }

  if (this.equals(Long.MIN_VALUE)) {
    if (other.equals(Long.ONE) ||
        other.equals(Long.NEG_ONE)) {
      return Long.MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
    } else if (other.equals(Long.MIN_VALUE)) {
      return Long.ONE;
    } else {
      // At this point, we have |other| &gt;= 2, so |this/other| &lt; |MIN_VALUE|.
      var halfThis = this.shiftRight(1);
      var approx = halfThis.div(other).shiftLeft(1);
      if (approx.equals(Long.ZERO)) {
        return other.isNegative() ? Long.ONE : Long.NEG_ONE;
      } else {
        var rem = this.subtract(other.multiply(approx));
        var result = approx.add(rem.div(other));
        return result;
      }
    }
  } else if (other.equals(Long.MIN_VALUE)) {
    return Long.ZERO;
  }

  if (this.isNegative()) {
    if (other.isNegative()) {
      return this.negate().div(other.negate());
    } else {
      return this.negate().div(other).negate();
    }
  } else if (other.isNegative()) {
    return this.div(other.negate()).negate();
  }

  // Repeat the following until the remainder is less than other:  find a
  // floating-point that approximates remainder / other *from below*, add this
  // into the result, and subtract it from the remainder.  It is critical that
  // the approximate value is less than or equal to the real value so that the
  // remainder never becomes negative.
  var res = Long.ZERO;
  var rem = this;
  while (rem.greaterThanOrEqual(other)) {
    // Approximate the result of division. This may be a little greater or
    // smaller than the actual value.
    var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));

    // We will tweak the approximate result by changing it in the 48-th digit or
    // the smallest non-fractional digit, whichever is larger.
    var log2 = Math.ceil(Math.log(approx) / Math.LN2);
    var delta = (log2 &lt;= 48) ? 1 : Math.pow(2, log2 - 48);

    // Decrease the approximation until it is smaller than the remainder.  Note
    // that if it is too large, the product overflows and is negative.
    var approxRes = Long.fromNumber(approx);
    var approxRem = approxRes.multiply(other);
    while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
      approx -= delta;
      approxRes = Long.fromNumber(approx);
      approxRem = approxRes.multiply(other);
    }

    // We know the answer can't be zero... and actually, zero would cause
    // infinite recursion since we would make no progress.
    if (approxRes.isZero()) {
      approxRes = Long.ONE;
    }

    res = res.add(approxRes);
    rem = rem.subtract(approxRem);
  }
  return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  for(var i = 0; i &lt;= 3; i++) {
    // Adjust remainder to match value of next dividend
    _rem = _rem.shiftLeft(32);
    // Add the divided to _rem
    _rem = _rem.add(new Long(value.parts[i], 0));
    value.parts[i] = _rem.<span class="apidocCodeKeywordSpan">div</span>(DIVISOR).low_;
    _rem = _rem.modulo(DIVISOR);
  }

  return { quotient: value, rem: _rem };
}

// Multiply two Long values and return the 128 bit value
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Long.prototype.equals" id="apidoc.element.bson.Long.prototype.equals">
        function <span class="apidocSignatureSpan">bson.Long.prototype.</span>equals
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">equals = function (other) {
  return (this.high_ == other.high_) &amp;&amp; (this.low_ == other.low_);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// Biased exponent
var biasedExponent = (exponent + EXPONENT_BIAS);
var dec = { low: Long.fromNumber(0), high: Long.fromNumber(0) };

// Encode combination, exponent, and significand.
if(significand.high.shiftRightUnsigned(49).and(Long.fromNumber(1)).<span class="apidocCodeKeywordSpan">equals</span>(Long.fromNumber
)) {
  // Encode '11' into bits 1 to 3
  dec.high = dec.high.or(Long.fromNumber(0x3).shiftLeft(61));
  dec.high = dec.high.or(Long.fromNumber(biasedExponent).and(Long.fromNumber(0x3fff).shiftLeft(47)));
  dec.high = dec.high.or(significand.high.and(Long.fromNumber(0x7fffffffffff)));
} else {
  dec.high = dec.high.or(Long.fromNumber(biasedExponent &amp; 0x3fff).shiftLeft(49));
  dec.high = dec.high.or(significand.high.and(Long.fromNumber(0x1ffffffffffff)));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Long.prototype.getHighBits" id="apidoc.element.bson.Long.prototype.getHighBits">
        function <span class="apidocSignatureSpan">bson.Long.prototype.</span>getHighBits
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getHighBits = function () {
  return this.high_;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Number of written bytes
var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
// Encode the name
index = index + numberOfWrittenBytes;
buffer[index++] = 0;
var longVal = Long.fromNumber(value);
var lowBits = longVal.getLowBits();
var highBits = longVal.<span class="apidocCodeKeywordSpan">getHighBits</span>();
// Encode low bits
buffer[index++] = lowBits &amp; 0xff;
buffer[index++] = (lowBits &gt;&gt; 8) &amp; 0xff;
buffer[index++] = (lowBits &gt;&gt; 16) &amp; 0xff;
buffer[index++] = (lowBits &gt;&gt; 24) &amp; 0xff;
// Encode high bits
buffer[index++] = highBits &amp; 0xff;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Long.prototype.getLowBits" id="apidoc.element.bson.Long.prototype.getLowBits">
        function <span class="apidocSignatureSpan">bson.Long.prototype.</span>getLowBits
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLowBits = function () {
  return this.low_;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Multiply two Long values and return the 128 bit value
var multiply64x2 = function(left, right) {
if(!left &amp;&amp; !right) {
  return {high: Long.fromNumber(0), low: Long.fromNumber(0)};
}

var leftHigh = left.shiftRightUnsigned(32);
var leftLow = new Long(left.<span class="apidocCodeKeywordSpan">getLowBits</span>(), 0);
var rightHigh = right.shiftRightUnsigned(32);
var rightLow = new Long(right.getLowBits(), 0);

var productHigh = leftHigh.multiply(rightHigh);
var productMid = leftHigh.multiply(rightLow);
var productMid2 = leftLow.multiply(rightHigh);
var productLow = leftLow.multiply(rightLow);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Long.prototype.getLowBitsUnsigned" id="apidoc.element.bson.Long.prototype.getLowBitsUnsigned">
        function <span class="apidocSignatureSpan">bson.Long.prototype.</span>getLowBitsUnsigned
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLowBitsUnsigned = function () {
  return (this.low_ &gt;= 0) ?
      this.low_ : Long.TWO_PWR_32_DBL_ + this.low_;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Return the Number value.
*
* @method
* @return {number} the closest floating-point representation to this value.
*/
Long.prototype.toNumber = function() {
 return this.high_ * Long.TWO_PWR_32_DBL_ +
        this.<span class="apidocCodeKeywordSpan">getLowBitsUnsigned</span>();
};

/**
* Return the JSON value.
*
* @method
* @return {string} the JSON representation.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Long.prototype.getNumBitsAbs" id="apidoc.element.bson.Long.prototype.getNumBitsAbs">
        function <span class="apidocSignatureSpan">bson.Long.prototype.</span>getNumBitsAbs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getNumBitsAbs = function () {
  if (this.isNegative()) {
    if (this.equals(Long.MIN_VALUE)) {
      return 64;
    } else {
      return this.negate().getNumBitsAbs();
    }
  } else {
    var val = this.high_ != 0 ? this.high_ : this.low_;
    for (var bit = 31; bit &gt; 0; bit--) {
      if ((val &amp; (1 &lt;&lt; bit)) != 0) {
        break;
      }
    }
    return this.high_ != 0 ? bit + 33 : bit + 1;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {number} Returns the number of bits needed to represent the absolute value of this Long.
 */
Long.prototype.getNumBitsAbs = function() {
if (this.isNegative()) {
  if (this.equals(Long.MIN_VALUE)) {
    return 64;
  } else {
    return this.negate().<span class="apidocCodeKeywordSpan">getNumBitsAbs</span>();
  }
} else {
  var val = this.high_ != 0 ? this.high_ : this.low_;
  for (var bit = 31; bit &gt; 0; bit--) {
    if ((val &amp; (1 &lt;&lt; bit)) != 0) {
      break;
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Long.prototype.greaterThan" id="apidoc.element.bson.Long.prototype.greaterThan">
        function <span class="apidocSignatureSpan">bson.Long.prototype.</span>greaterThan
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">greaterThan = function (other) {
  return this.compare(other) &gt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var log2 = Math.ceil(Math.log(approx) / Math.LN2);
var delta = (log2 &lt;= 48) ? 1 : Math.pow(2, log2 - 48);

// Decrease the approximation until it is smaller than the remainder.  Note
// that if it is too large, the product overflows and is negative.
var approxRes = Long.fromNumber(approx);
var approxRem = approxRes.multiply(other);
while (approxRem.isNegative() || approxRem.<span class="apidocCodeKeywordSpan">greaterThan</span>(rem)) {
  approx -= delta;
  approxRes = Long.fromNumber(approx);
  approxRem = approxRes.multiply(other);
}

// We know the answer can't be zero... and actually, zero would cause
// infinite recursion since we would make no progress.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Long.prototype.greaterThanOrEqual" id="apidoc.element.bson.Long.prototype.greaterThanOrEqual">
        function <span class="apidocSignatureSpan">bson.Long.prototype.</span>greaterThanOrEqual
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">greaterThanOrEqual = function (other) {
  return this.compare(other) &gt;= 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // Repeat the following until the remainder is less than other:  find a
  // floating-point that approximates remainder / other *from below*, add this
  // into the result, and subtract it from the remainder.  It is critical that
  // the approximate value is less than or equal to the real value so that the
  // remainder never becomes negative.
  var res = Long.ZERO;
  var rem = this;
  while (rem.<span class="apidocCodeKeywordSpan">greaterThanOrEqual</span>(other)) {
// Approximate the result of division. This may be a little greater or
// smaller than the actual value.
var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));

// We will tweak the approximate result by changing it in the 48-th digit or
// the smallest non-fractional digit, whichever is larger.
var log2 = Math.ceil(Math.log(approx) / Math.LN2);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Long.prototype.isNegative" id="apidoc.element.bson.Long.prototype.isNegative">
        function <span class="apidocSignatureSpan">bson.Long.prototype.</span>isNegative
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNegative = function () {
  return this.high_ &lt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  throw Error('radix out of range: ' + radix);
}

if (this.isZero()) {
  return '0';
}

if (this.<span class="apidocCodeKeywordSpan">isNegative</span>()) {
  if (this.equals(Long.MIN_VALUE)) {
    // We need to change the Long value before it can be negated, so we remove
    // the bottom-most digit in this base and then recurse to do the rest.
    var radixLong = Long.fromNumber(radix);
    var div = this.div(radixLong);
    var rem = div.multiply(radixLong).subtract(this);
    return div.toString(radix) + rem.toInt().toString(radix);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Long.prototype.isOdd" id="apidoc.element.bson.Long.prototype.isOdd">
        function <span class="apidocSignatureSpan">bson.Long.prototype.</span>isOdd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isOdd = function () {
  return (this.low_ &amp; 1) == 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.isZero()) {
  return Long.ZERO;
} else if (other.isZero()) {
  return Long.ZERO;
}

if (this.equals(Long.MIN_VALUE)) {
  return other.<span class="apidocCodeKeywordSpan">isOdd</span>() ? Long.MIN_VALUE : Long.ZERO;
} else if (other.equals(Long.MIN_VALUE)) {
  return this.isOdd() ? Long.MIN_VALUE : Long.ZERO;
}

if (this.isNegative()) {
  if (other.isNegative()) {
    return this.negate().multiply(other.negate());
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Long.prototype.isZero" id="apidoc.element.bson.Long.prototype.isZero">
        function <span class="apidocSignatureSpan">bson.Long.prototype.</span>isZero
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isZero = function () {
  return this.high_ == 0 &amp;&amp; this.low_ == 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
Long.prototype.toString = function(opt_radix) {
var radix = opt_radix || 10;
if (radix &lt; 2 || 36 &lt; radix) {
  throw Error('radix out of range: ' + radix);
}

if (this.<span class="apidocCodeKeywordSpan">isZero</span>()) {
  return '0';
}

if (this.isNegative()) {
  if (this.equals(Long.MIN_VALUE)) {
    // We need to change the Long value before it can be negated, so we remove
    // the bottom-most digit in this base and then recurse to do the rest.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Long.prototype.lessThan" id="apidoc.element.bson.Long.prototype.lessThan">
        function <span class="apidocSignatureSpan">bson.Long.prototype.</span>lessThan
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lessThan = function (other) {
  return this.compare(other) &lt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var index = 0;

// Create the state of the decimal
var dec = {
  low: new Long(low, midl),
  high: new Long(midh, high) };

if(dec.high.<span class="apidocCodeKeywordSpan">lessThan</span>(Long.ZERO)) {
  string.push('-');
}

// Decode combination field and exponent
combination = (high &gt;&gt; 26) &amp; COMBINATION_MASK;

if((combination &gt;&gt; 3) == 3) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Long.prototype.lessThanOrEqual" id="apidoc.element.bson.Long.prototype.lessThanOrEqual">
        function <span class="apidocSignatureSpan">bson.Long.prototype.</span>lessThanOrEqual
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lessThanOrEqual = function (other) {
  return this.compare(other) &lt;= 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		} else if(elementType == BSON.BSON_DATA_LONG) {
      // Unpack the low and high bits
      var lowBits = buffer[index++] | buffer[index++] &lt;&lt; 8 | buffer[index++] &lt;&lt; 16 | buffer[index++] &lt;&amp;#
x3c; 24;
      var highBits = buffer[index++] | buffer[index++] &lt;&lt; 8 | buffer[index++] &lt;&lt; 16 | buffer[index++] &lt;&amp;#
x3c; 24;
      var long = new Long(lowBits, highBits);
      // Promote the long if possible
      if(promoteLongs &amp;&amp; promoteValues == true) {
        object[name] = long.<span class="apidocCodeKeywordSpan">lessThanOrEqual</span>(JS_INT_MAX_LONG) &amp;&amp; long.greaterThanOrEqual
(JS_INT_MIN_LONG) ? long.toNumber() : long;
      } else {
        object[name] = long;
      }
		} else if(elementType == BSON.BSON_DATA_DECIMAL128) {
			// Buffer to contain the decimal bytes
			var bytes = new Buffer(16);
			// Copy the next 16 bytes into the bytes buffer
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Long.prototype.modulo" id="apidoc.element.bson.Long.prototype.modulo">
        function <span class="apidocSignatureSpan">bson.Long.prototype.</span>modulo
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">modulo = function (other) {
  return this.subtract(this.div(other).multiply(other));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  for(var i = 0; i &lt;= 3; i++) {
    // Adjust remainder to match value of next dividend
    _rem = _rem.shiftLeft(32);
    // Add the divided to _rem
    _rem = _rem.add(new Long(value.parts[i], 0));
    value.parts[i] = _rem.div(DIVISOR).low_;
    _rem = _rem.<span class="apidocCodeKeywordSpan">modulo</span>(DIVISOR);
  }

  return { quotient: value, rem: _rem };
}

// Multiply two Long values and return the 128 bit value
var multiply64x2 = function(left, right) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Long.prototype.multiply" id="apidoc.element.bson.Long.prototype.multiply">
        function <span class="apidocSignatureSpan">bson.Long.prototype.</span>multiply
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">multiply = function (other) {
  if (this.isZero()) {
    return Long.ZERO;
  } else if (other.isZero()) {
    return Long.ZERO;
  }

  if (this.equals(Long.MIN_VALUE)) {
    return other.isOdd() ? Long.MIN_VALUE : Long.ZERO;
  } else if (other.equals(Long.MIN_VALUE)) {
    return this.isOdd() ? Long.MIN_VALUE : Long.ZERO;
  }

  if (this.isNegative()) {
    if (other.isNegative()) {
      return this.negate().multiply(other.negate());
    } else {
      return this.negate().multiply(other).negate();
    }
  } else if (other.isNegative()) {
    return this.multiply(other.negate()).negate();
  }

  // If both Longs are small, use float multiplication
  if (this.lessThan(Long.TWO_PWR_24_) &amp;&amp;
      other.lessThan(Long.TWO_PWR_24_)) {
    return Long.fromNumber(this.toNumber() * other.toNumber());
  }

  // Divide each Long into 4 chunks of 16 bits, and then add up 4x4 products.
  // We can skip products that would overflow.

  var a48 = this.high_ &gt;&gt;&gt; 16;
  var a32 = this.high_ &amp; 0xFFFF;
  var a16 = this.low_ &gt;&gt;&gt; 16;
  var a00 = this.low_ &amp; 0xFFFF;

  var b48 = other.high_ &gt;&gt;&gt; 16;
  var b32 = other.high_ &amp; 0xFFFF;
  var b16 = other.low_ &gt;&gt;&gt; 16;
  var b00 = other.low_ &amp; 0xFFFF;

  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 * b00;
  c16 += c00 &gt;&gt;&gt; 16;
  c00 &amp;= 0xFFFF;
  c16 += a16 * b00;
  c32 += c16 &gt;&gt;&gt; 16;
  c16 &amp;= 0xFFFF;
  c16 += a00 * b16;
  c32 += c16 &gt;&gt;&gt; 16;
  c16 &amp;= 0xFFFF;
  c32 += a32 * b00;
  c48 += c32 &gt;&gt;&gt; 16;
  c32 &amp;= 0xFFFF;
  c32 += a16 * b16;
  c48 += c32 &gt;&gt;&gt; 16;
  c32 &amp;= 0xFFFF;
  c32 += a00 * b32;
  c48 += c32 &gt;&gt;&gt; 16;
  c32 &amp;= 0xFFFF;
  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
  c48 &amp;= 0xFFFF;
  return Long.fromBits((c16 &lt;&lt; 16) | c00, (c48 &lt;&lt; 16) | c32);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

var leftHigh = left.shiftRightUnsigned(32);
var leftLow = new Long(left.getLowBits(), 0);
var rightHigh = right.shiftRightUnsigned(32);
var rightLow = new Long(right.getLowBits(), 0);

var productHigh = leftHigh.<span class="apidocCodeKeywordSpan">multiply</span>(rightHigh);
var productMid = leftHigh.multiply(rightLow);
var productMid2 = leftLow.multiply(rightHigh);
var productLow = leftLow.multiply(rightLow);

productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
productMid = new Long(productMid.getLowBits(), 0)
              .add(productMid2)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Long.prototype.negate" id="apidoc.element.bson.Long.prototype.negate">
        function <span class="apidocSignatureSpan">bson.Long.prototype.</span>negate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">negate = function () {
  if (this.equals(Long.MIN_VALUE)) {
    return Long.MIN_VALUE;
  } else {
    return this.not().add(Long.ONE);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // We need to change the Long value before it can be negated, so we remove
    // the bottom-most digit in this base and then recurse to do the rest.
    var radixLong = Long.fromNumber(radix);
    var div = this.div(radixLong);
    var rem = div.multiply(radixLong).subtract(this);
    return div.toString(radix) + rem.toInt().toString(radix);
  } else {
    return '-' + this.<span class="apidocCodeKeywordSpan">negate</span>().toString(radix);
  }
}

// Do several (6) digits each time through the loop, so as to
// minimize the calls to the very expensive emulated div.
var radixToPower = Long.fromNumber(Math.pow(radix, 6));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Long.prototype.not" id="apidoc.element.bson.Long.prototype.not">
        function <span class="apidocSignatureSpan">bson.Long.prototype.</span>not
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">not = function () {
  return Long.fromBits(~this.low_, ~this.high_);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @method
* @return {Long} the negation of this value.
*/
Long.prototype.negate = function() {
 if (this.equals(Long.MIN_VALUE)) {
   return Long.MIN_VALUE;
 } else {
   return this.<span class="apidocCodeKeywordSpan">not</span>().add(Long.ONE);
 }
};

/**
* Returns the sum of this and the given Long.
*
* @method
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Long.prototype.notEquals" id="apidoc.element.bson.Long.prototype.notEquals">
        function <span class="apidocSignatureSpan">bson.Long.prototype.</span>notEquals
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notEquals = function (other) {
  return (this.high_ != other.high_) || (this.low_ != other.low_);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Long.prototype.or" id="apidoc.element.bson.Long.prototype.or">
        function <span class="apidocSignatureSpan">bson.Long.prototype.</span>or
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">or = function (other) {
  return Long.fromBits(this.low_ | other.low_, this.high_ | other.high_);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Biased exponent
var biasedExponent = (exponent + EXPONENT_BIAS);
var dec = { low: Long.fromNumber(0), high: Long.fromNumber(0) };

// Encode combination, exponent, and significand.
if(significand.high.shiftRightUnsigned(49).and(Long.fromNumber(1)).equals(Long.fromNumber)) {
  // Encode '11' into bits 1 to 3
  dec.high = dec.high.<span class="apidocCodeKeywordSpan">or</span>(Long.fromNumber(0x3).shiftLeft(61));
  dec.high = dec.high.or(Long.fromNumber(biasedExponent).and(Long.fromNumber(0x3fff).shiftLeft(47)));
  dec.high = dec.high.or(significand.high.and(Long.fromNumber(0x7fffffffffff)));
} else {
  dec.high = dec.high.or(Long.fromNumber(biasedExponent &amp; 0x3fff).shiftLeft(49));
  dec.high = dec.high.or(significand.high.and(Long.fromNumber(0x1ffffffffffff)));
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Long.prototype.shiftLeft" id="apidoc.element.bson.Long.prototype.shiftLeft">
        function <span class="apidocSignatureSpan">bson.Long.prototype.</span>shiftLeft
        <span class="apidocSignatureSpan">(numBits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shiftLeft = function (numBits) {
  numBits &amp;= 63;
  if (numBits == 0) {
    return this;
  } else {
    var low = this.low_;
    if (numBits &lt; 32) {
      var high = this.high_;
      return Long.fromBits(
                 low &lt;&lt; numBits,
                 (high &lt;&lt; numBits) | (low &gt;&gt;&gt; (32 - numBits)));
    } else {
      return Long.fromBits(0, low &lt;&lt; (numBits - 32));
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(!value.parts[0] &amp;&amp; !value.parts[1] &amp;&amp;
   !value.parts[2] &amp;&amp; !value.parts[3]) {
  return { quotient: value, rem: _rem };
}

for(var i = 0; i &lt;= 3; i++) {
  // Adjust remainder to match value of next dividend
  _rem = _rem.<span class="apidocCodeKeywordSpan">shiftLeft</span>(32);
  // Add the divided to _rem
  _rem = _rem.add(new Long(value.parts[i], 0));
  value.parts[i] = _rem.div(DIVISOR).low_;
  _rem = _rem.modulo(DIVISOR);
}

return { quotient: value, rem: _rem };
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Long.prototype.shiftRight" id="apidoc.element.bson.Long.prototype.shiftRight">
        function <span class="apidocSignatureSpan">bson.Long.prototype.</span>shiftRight
        <span class="apidocSignatureSpan">(numBits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shiftRight = function (numBits) {
  numBits &amp;= 63;
  if (numBits == 0) {
    return this;
  } else {
    var high = this.high_;
    if (numBits &lt; 32) {
      var low = this.low_;
      return Long.fromBits(
                 (low &gt;&gt;&gt; numBits) | (high &lt;&lt; (32 - numBits)),
                 high &gt;&gt; numBits);
    } else {
      return Long.fromBits(
                 high &gt;&gt; (numBits - 32),
                 high &gt;= 0 ? 0 : -1);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (other.equals(Long.ONE) ||
    other.equals(Long.NEG_ONE)) {
  return Long.MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
} else if (other.equals(Long.MIN_VALUE)) {
  return Long.ONE;
} else {
  // At this point, we have |other| &gt;= 2, so |this/other| &lt; |MIN_VALUE|.
  var halfThis = this.<span class="apidocCodeKeywordSpan">shiftRight</span>(1);
  var approx = halfThis.div(other).shiftLeft(1);
  if (approx.equals(Long.ZERO)) {
    return other.isNegative() ? Long.ONE : Long.NEG_ONE;
  } else {
    var rem = this.subtract(other.multiply(approx));
    var result = approx.add(rem.div(other));
    return result;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Long.prototype.shiftRightUnsigned" id="apidoc.element.bson.Long.prototype.shiftRightUnsigned">
        function <span class="apidocSignatureSpan">bson.Long.prototype.</span>shiftRightUnsigned
        <span class="apidocSignatureSpan">(numBits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shiftRightUnsigned = function (numBits) {
  numBits &amp;= 63;
  if (numBits == 0) {
    return this;
  } else {
    var high = this.high_;
    if (numBits &lt; 32) {
      var low = this.low_;
      return Long.fromBits(
                 (low &gt;&gt;&gt; numBits) | (high &lt;&lt; (32 - numBits)),
                 high &gt;&gt;&gt; numBits);
    } else if (numBits == 32) {
      return Long.fromBits(high, 0);
    } else {
      return Long.fromBits(high &gt;&gt;&gt; (numBits - 32), 0);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Multiply two Long values and return the 128 bit value
var multiply64x2 = function(left, right) {
if(!left &amp;&amp; !right) {
  return {high: Long.fromNumber(0), low: Long.fromNumber(0)};
}

var leftHigh = left.<span class="apidocCodeKeywordSpan">shiftRightUnsigned</span>(32);
var leftLow = new Long(left.getLowBits(), 0);
var rightHigh = right.shiftRightUnsigned(32);
var rightLow = new Long(right.getLowBits(), 0);

var productHigh = leftHigh.multiply(rightHigh);
var productMid = leftHigh.multiply(rightLow);
var productMid2 = leftLow.multiply(rightHigh);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Long.prototype.subtract" id="apidoc.element.bson.Long.prototype.subtract">
        function <span class="apidocSignatureSpan">bson.Long.prototype.</span>subtract
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subtract = function (other) {
  return this.add(other.negate());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (this.isNegative()) {
  if (this.equals(Long.MIN_VALUE)) {
    // We need to change the Long value before it can be negated, so we remove
    // the bottom-most digit in this base and then recurse to do the rest.
    var radixLong = Long.fromNumber(radix);
    var div = this.div(radixLong);
    var rem = div.multiply(radixLong).<span class="apidocCodeKeywordSpan">subtract</span>(this);
    return div.toString(radix) + rem.toInt().toString(radix);
  } else {
    return '-' + this.negate().toString(radix);
  }
}

// Do several (6) digits each time through the loop, so as to
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Long.prototype.toInt" id="apidoc.element.bson.Long.prototype.toInt">
        function <span class="apidocSignatureSpan">bson.Long.prototype.</span>toInt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toInt = function () {
  return this.low_;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.isNegative()) {
  if (this.equals(Long.MIN_VALUE)) {
    // We need to change the Long value before it can be negated, so we remove
    // the bottom-most digit in this base and then recurse to do the rest.
    var radixLong = Long.fromNumber(radix);
    var div = this.div(radixLong);
    var rem = div.multiply(radixLong).subtract(this);
    return div.toString(radix) + rem.<span class="apidocCodeKeywordSpan">toInt</span>().toString(radix);
  } else {
    return '-' + this.negate().toString(radix);
  }
}

// Do several (6) digits each time through the loop, so as to
// minimize the calls to the very expensive emulated div.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Long.prototype.toJSON" id="apidoc.element.bson.Long.prototype.toJSON">
        function <span class="apidocSignatureSpan">bson.Long.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  return this.toString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

	'use strict';
	var $export     = __webpack_require__(8)
	  , toObject    = __webpack_require__(58)
	  , toPrimitive = __webpack_require__(16);

	$export($export.P + $export.F * __webpack_require__(7)(function(){
	  return new Date(NaN).<span class="apidocCodeKeywordSpan">toJSON</span>() !== null || Date.prototype.toJSON.call({toISOString:
function(){ return 1; }}) !== 1;
	}), 'Date', {
	  toJSON: function toJSON(key){
	    var O  = toObject(this)
	      , pv = toPrimitive(O);
	    return typeof pv == 'number' &amp;&amp; !isFinite(pv) ? null : O.toISOString();
	  }
	});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Long.prototype.toNumber" id="apidoc.element.bson.Long.prototype.toNumber">
        function <span class="apidocSignatureSpan">bson.Long.prototype.</span>toNumber
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toNumber = function () {
  return this.high_ * Long.TWO_PWR_32_DBL_ +
         this.getLowBitsUnsigned();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else if (other.isNegative()) {
  return this.multiply(other.negate()).negate();
}

// If both Longs are small, use float multiplication
if (this.lessThan(Long.TWO_PWR_24_) &amp;&amp;
    other.lessThan(Long.TWO_PWR_24_)) {
  return Long.fromNumber(this.<span class="apidocCodeKeywordSpan">toNumber</span>() * other.toNumber());
}

// Divide each Long into 4 chunks of 16 bits, and then add up 4x4 products.
// We can skip products that would overflow.

var a48 = this.high_ &gt;&gt;&gt; 16;
var a32 = this.high_ &amp; 0xFFFF;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Long.prototype.toString" id="apidoc.element.bson.Long.prototype.toString">
        function <span class="apidocSignatureSpan">bson.Long.prototype.</span>toString
        <span class="apidocSignatureSpan">(opt_radix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function (opt_radix) {
  var radix = opt_radix || 10;
  if (radix &lt; 2 || 36 &lt; radix) {
    throw Error('radix out of range: ' + radix);
  }

  if (this.isZero()) {
    return '0';
  }

  if (this.isNegative()) {
    if (this.equals(Long.MIN_VALUE)) {
      // We need to change the Long value before it can be negated, so we remove
      // the bottom-most digit in this base and then recurse to do the rest.
      var radixLong = Long.fromNumber(radix);
      var div = this.div(radixLong);
      var rem = div.multiply(radixLong).subtract(this);
      return div.toString(radix) + rem.toInt().toString(radix);
    } else {
      return '-' + this.negate().toString(radix);
    }
  }

  // Do several (6) digits each time through the loop, so as to
  // minimize the calls to the very expensive emulated div.
  var radixToPower = Long.fromNumber(Math.pow(radix, 6));

  var rem = this;
  var result = '';
  while (true) {
    var remDiv = rem.div(radixToPower);
    var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
    var digits = intval.toString(radix);

    rem = remDiv;
    if (rem.isZero()) {
      return digits + result;
    } else {
      while (digits.length &lt; 6) {
        digits = '0' + digits;
      }
      result = '' + digits + result;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/***/ },
/* 19 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).<span class="apidocCodeKeywordSpan
">toString</span>(36));
	};

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Long.prototype.xor" id="apidoc.element.bson.Long.prototype.xor">
        function <span class="apidocSignatureSpan">bson.Long.prototype.</span>xor
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">xor = function (other) {
  return Long.fromBits(this.low_ ^ other.low_, this.high_ ^ other.high_);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bson.Map" id="apidoc.module.bson.Map">module bson.Map</a></h1>


    <h2>
        <a href="#apidoc.element.bson.Map.Map" id="apidoc.element.bson.Map.Map">
        function <span class="apidocSignatureSpan">bson.</span>Map
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Map() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bson.MaxKey" id="apidoc.module.bson.MaxKey">module bson.MaxKey</a></h1>


    <h2>
        <a href="#apidoc.element.bson.MaxKey.MaxKey" id="apidoc.element.bson.MaxKey.MaxKey">
        function <span class="apidocSignatureSpan">bson.</span>MaxKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MaxKey() {
  if(!(this instanceof MaxKey)) return new MaxKey();

  this._bsontype = 'MaxKey';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bson.MinKey" id="apidoc.module.bson.MinKey">module bson.MinKey</a></h1>


    <h2>
        <a href="#apidoc.element.bson.MinKey.MinKey" id="apidoc.element.bson.MinKey.MinKey">
        function <span class="apidocSignatureSpan">bson.</span>MinKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MinKey() {
  if(!(this instanceof MinKey)) return new MinKey();

  this._bsontype = 'MinKey';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bson.ObjectID" id="apidoc.module.bson.ObjectID">module bson.ObjectID</a></h1>


    <h2>
        <a href="#apidoc.element.bson.ObjectID.ObjectID" id="apidoc.element.bson.ObjectID.ObjectID">
        function <span class="apidocSignatureSpan">bson.</span>ObjectID
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ObjectID(id) {
  // Duck-typing to support ObjectId from different npm packages
  if(id instanceof ObjectID) return id;
  if(!(this instanceof ObjectID)) return new ObjectID(id);

  this._bsontype = 'ObjectID';

  // The most common usecase (blank id, new objectId instance)
  if(id == null || typeof id == 'number') {
    // Generate a new id
    this.id = this.generate(id);
    // If we are caching the hex string
    if(ObjectID.cacheHexString) this.__id = this.toString('hex');
    // Return the object
    return;
  }

  // Check if the passed in id is valid
  var valid = ObjectID.isValid(id);

  // Throw an error if it's not a valid setup
  if(!valid &amp;&amp; id != null){
    throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
  } else if(valid &amp;&amp; typeof id == 'string' &amp;&amp; id.length == 24 &amp;&amp; hasBufferType) {
    return new ObjectID(new Buffer(id, 'hex'));
  } else if(valid &amp;&amp; typeof id == 'string' &amp;&amp; id.length == 24) {
    return ObjectID.createFromHexString(id);
  } else if(id != null &amp;&amp; id.length === 12) {
    // assume 12 byte string
    this.id = id;
  } else if(id != null &amp;&amp; id.toHexString) {
    // Duck-typing to support ObjectId from different npm packages
    return id;
  } else {
    throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
  }

  if(ObjectID.cacheHexString) this.__id = this.toString('hex');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.ObjectID.ObjectId" id="apidoc.element.bson.ObjectID.ObjectId">
        function <span class="apidocSignatureSpan">bson.ObjectID.</span>ObjectId
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ObjectID(id) {
  // Duck-typing to support ObjectId from different npm packages
  if(id instanceof ObjectID) return id;
  if(!(this instanceof ObjectID)) return new ObjectID(id);

  this._bsontype = 'ObjectID';

  // The most common usecase (blank id, new objectId instance)
  if(id == null || typeof id == 'number') {
    // Generate a new id
    this.id = this.generate(id);
    // If we are caching the hex string
    if(ObjectID.cacheHexString) this.__id = this.toString('hex');
    // Return the object
    return;
  }

  // Check if the passed in id is valid
  var valid = ObjectID.isValid(id);

  // Throw an error if it's not a valid setup
  if(!valid &amp;&amp; id != null){
    throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
  } else if(valid &amp;&amp; typeof id == 'string' &amp;&amp; id.length == 24 &amp;&amp; hasBufferType) {
    return new ObjectID(new Buffer(id, 'hex'));
  } else if(valid &amp;&amp; typeof id == 'string' &amp;&amp; id.length == 24) {
    return ObjectID.createFromHexString(id);
  } else if(id != null &amp;&amp; id.length === 12) {
    // assume 12 byte string
    this.id = id;
  } else if(id != null &amp;&amp; id.toHexString) {
    // Duck-typing to support ObjectId from different npm packages
    return id;
  } else {
    throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
  }

  if(ObjectID.cacheHexString) this.__id = this.toString('hex');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.ObjectID.createFromHexString" id="apidoc.element.bson.ObjectID.createFromHexString">
        function <span class="apidocSignatureSpan">bson.ObjectID.</span>createFromHexString
        <span class="apidocSignatureSpan">(string)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createFromHexString(string) {
  // Throw an error if it's not a valid setup
  if(typeof string === 'undefined' || string != null &amp;&amp; string.length != 24) {
    throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
  }

  // Use Buffer.from method if available
  if(hasBufferType) return new ObjectID(new Buffer(string, 'hex'));

  // Calculate lengths
  var array = new _Buffer(12);
  var n = 0;
  var i = 0;

  while (i &lt; 24) {
    array[n++] = decodeLookup[string.charCodeAt(i++)] &lt;&lt; 4 | decodeLookup[string.charCodeAt(i++)]
  }

  return new ObjectID(array);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Throw an error if it's not a valid setup
if(!valid &amp;&amp; id != null){
  throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
} else if(valid &amp;&amp; typeof id == 'string' &amp;&amp; id.length == 24 &amp;&amp; hasBufferType) {
  return new ObjectID(new Buffer(id, 'hex'));
} else if(valid &amp;&amp; typeof id == 'string' &amp;&amp; id.length == 24) {
  return ObjectID.<span class="apidocCodeKeywordSpan">createFromHexString</span>(id);
} else if(id != null &amp;&amp; id.length === 12) {
  // assume 12 byte string
  this.id = id;
} else if(id != null &amp;&amp; id.toHexString) {
  // Duck-typing to support ObjectId from different npm packages
  return id;
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.ObjectID.createFromTime" id="apidoc.element.bson.ObjectID.createFromTime">
        function <span class="apidocSignatureSpan">bson.ObjectID.</span>createFromTime
        <span class="apidocSignatureSpan">(time)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createFromTime(time) {
  var buffer = new Buffer([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
  // Encode time into first 4 bytes
  buffer[3] = time &amp; 0xff;
  buffer[2] = (time &gt;&gt; 8) &amp; 0xff;
  buffer[1] = (time &gt;&gt; 16) &amp; 0xff;
  buffer[0] = (time &gt;&gt; 24) &amp; 0xff;
  // Return the new objectId
  return new ObjectID(buffer);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.ObjectID.createPk" id="apidoc.element.bson.ObjectID.createPk">
        function <span class="apidocSignatureSpan">bson.ObjectID.</span>createPk
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createPk() {
  return new ObjectID();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.ObjectID.isValid" id="apidoc.element.bson.ObjectID.isValid">
        function <span class="apidocSignatureSpan">bson.ObjectID.</span>isValid
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isValid(id) {
  if(id == null) return false;

  if(typeof id == 'number') {
    return true;
  }

  if(typeof id == 'string') {
    return id.length == 12 || (id.length == 24 &amp;&amp; checkForHexRegExp.test(id));
  }

  if(id instanceof ObjectID) {
    return true;
  }

  if(id instanceof _Buffer) {
    return true;
  }

  // Duck-Typing detection of ObjectId like objects
  if(id.toHexString) {
    return id.id.length == 12 || (id.id.length == 24 &amp;&amp; checkForHexRegExp.test(id.id));
  }

  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // If we are caching the hex string
  if(ObjectID.cacheHexString) this.__id = this.toString('hex');
  // Return the object
  return;
}

// Check if the passed in id is valid
var valid = ObjectID.<span class="apidocCodeKeywordSpan">isValid</span>(id);

// Throw an error if it's not a valid setup
if(!valid &amp;&amp; id != null){
  throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
} else if(valid &amp;&amp; typeof id == 'string' &amp;&amp; id.length == 24 &amp;&amp; hasBufferType) {
  return new ObjectID(new Buffer(id, 'hex'));
} else if(valid &amp;&amp; typeof id == 'string' &amp;&amp; id.length == 24) {
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bson.ObjectID.prototype" id="apidoc.module.bson.ObjectID.prototype">module bson.ObjectID.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.bson.ObjectID.prototype.equals" id="apidoc.element.bson.ObjectID.prototype.equals">
        function <span class="apidocSignatureSpan">bson.ObjectID.prototype.</span>equals
        <span class="apidocSignatureSpan">(otherId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function equals(otherId) {
  var id;

  if(otherId instanceof ObjectID) {
    return this.toString() == otherId.toString();
  } else if(typeof otherId == 'string' &amp;&amp; ObjectID.isValid(otherId) &amp;&amp; otherId.length == 12 &amp;&amp; this.id instanceof _Buffer) {
    return otherId === this.id.toString('binary');
  } else if(typeof otherId == 'string' &amp;&amp; ObjectID.isValid(otherId) &amp;&amp; otherId.length == 24) {
    return otherId.toLowerCase() === this.toHexString();
  } else if(typeof otherId == 'string' &amp;&amp; ObjectID.isValid(otherId) &amp;&amp; otherId.length == 12) {
    return otherId === this.id;
  } else if(otherId != null &amp;&amp; (otherId instanceof ObjectID || otherId.toHexString)) {
    return otherId.toHexString() === this.toHexString();
  } else {
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// Biased exponent
var biasedExponent = (exponent + EXPONENT_BIAS);
var dec = { low: Long.fromNumber(0), high: Long.fromNumber(0) };

// Encode combination, exponent, and significand.
if(significand.high.shiftRightUnsigned(49).and(Long.fromNumber(1)).<span class="apidocCodeKeywordSpan">equals</span>(Long.fromNumber
)) {
  // Encode '11' into bits 1 to 3
  dec.high = dec.high.or(Long.fromNumber(0x3).shiftLeft(61));
  dec.high = dec.high.or(Long.fromNumber(biasedExponent).and(Long.fromNumber(0x3fff).shiftLeft(47)));
  dec.high = dec.high.or(significand.high.and(Long.fromNumber(0x7fffffffffff)));
} else {
  dec.high = dec.high.or(Long.fromNumber(biasedExponent &amp; 0x3fff).shiftLeft(49));
  dec.high = dec.high.or(significand.high.and(Long.fromNumber(0x1ffffffffffff)));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.ObjectID.prototype.generate" id="apidoc.element.bson.ObjectID.prototype.generate">
        function <span class="apidocSignatureSpan">bson.ObjectID.prototype.</span>generate
        <span class="apidocSignatureSpan">(time)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generate = function (time) {
  if ('number' != typeof time) {
    time = ~~(Date.now()/1000);
  }

  // Use pid
  var pid = (typeof process === 'undefined' ? Math.floor(Math.random() * 100000) : process.pid) % 0xFFFF;
  var inc = this.get_inc();
  // Buffer used
  var buffer = new Buffer(12);
  // Encode time
  buffer[3] = time &amp; 0xff;
  buffer[2] = (time &gt;&gt; 8) &amp; 0xff;
  buffer[1] = (time &gt;&gt; 16) &amp; 0xff;
  buffer[0] = (time &gt;&gt; 24) &amp; 0xff;
  // Encode machine
  buffer[6] = MACHINE_ID &amp; 0xff;
  buffer[5] = (MACHINE_ID &gt;&gt; 8) &amp; 0xff;
  buffer[4] = (MACHINE_ID &gt;&gt; 16) &amp; 0xff;
  // Encode pid
  buffer[8] = pid &amp; 0xff;
  buffer[7] = (pid &gt;&gt; 8) &amp; 0xff;
  // Encode index
  buffer[11] = inc &amp; 0xff;
  buffer[10] = (inc &gt;&gt; 8) &amp; 0xff;
  buffer[9] = (inc &gt;&gt; 16) &amp; 0xff;
  // Return the buffer
  return buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(!(this instanceof ObjectID)) return new ObjectID(id);

this._bsontype = 'ObjectID';

// The most common usecase (blank id, new objectId instance)
if(id == null || typeof id == 'number') {
  // Generate a new id
  this.id = this.<span class="apidocCodeKeywordSpan">generate</span>(id);
  // If we are caching the hex string
  if(ObjectID.cacheHexString) this.__id = this.toString('hex');
  // Return the object
  return;
}

// Check if the passed in id is valid
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.ObjectID.prototype.getInc" id="apidoc.element.bson.ObjectID.prototype.getInc">
        function <span class="apidocSignatureSpan">bson.ObjectID.prototype.</span>getInc
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getInc = function () {
  return this.get_inc();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.ObjectID.prototype.getTimestamp" id="apidoc.element.bson.ObjectID.prototype.getTimestamp">
        function <span class="apidocSignatureSpan">bson.ObjectID.prototype.</span>getTimestamp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTimestamp = function () {
  var timestamp = new Date();
  var time = this.id[3] | this.id[2] &lt;&lt; 8 | this.id[1] &lt;&lt; 16 | this.id[0] &lt;&lt; 24;
  timestamp.setTime(Math.floor(time) * 1000);
  return timestamp;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.ObjectID.prototype.get_inc" id="apidoc.element.bson.ObjectID.prototype.get_inc">
        function <span class="apidocSignatureSpan">bson.ObjectID.prototype.</span>get_inc
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_inc = function () {
  return ObjectID.index = (ObjectID.index + 1) % 0xFFFFFF;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Update the ObjectID index used in generating new ObjectID's on the driver
*
* @method
* @return {number} returns next index value.
* @ignore
*/
ObjectID.prototype.getInc = function() {
  return this.<span class="apidocCodeKeywordSpan">get_inc</span>();
};

/**
* Generate a 12 byte id buffer used in ObjectID's
*
* @method
* @param {number} [time] optional parameter allowing to pass in a second based timestamp.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.ObjectID.prototype.inspect" id="apidoc.element.bson.ObjectID.prototype.inspect">
        function <span class="apidocSignatureSpan">bson.ObjectID.prototype.</span>inspect
        <span class="apidocSignatureSpan">(format)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function (format) {
  // Is the id a buffer then use the buffer toString method to return the format
  if(this.id &amp;&amp; this.id.copy) {
    return this.id.toString(typeof format === 'string' ? format : 'hex');
  }

  // if(this.buffer )
  return this.toHexString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.ObjectID.prototype.toHexString" id="apidoc.element.bson.ObjectID.prototype.toHexString">
        function <span class="apidocSignatureSpan">bson.ObjectID.prototype.</span>toHexString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toHexString = function () {
  if(ObjectID.cacheHexString &amp;&amp; this.__id) return this.__id;

  var hexString = '';
  if(!this.id || !this.id.length) {
    throw new Error('invalid ObjectId, ObjectId.id must be either a string or a Buffer, but is [' + JSON.stringify(this.id) + ']');
  }

  if(this.id instanceof _Buffer) {
    hexString = convertToHex(this.id);
    if(ObjectID.cacheHexString) this.__id = hexString;
    return hexString;
  }

  for (var i = 0; i &lt; this.id.length; i++) {
    hexString += hexTable[this.id.charCodeAt(i)];
  }

  if(ObjectID.cacheHexString) this.__id = hexString;
  return hexString;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
ObjectID.prototype.toString = function(format) {
  // Is the id a buffer then use the buffer toString method to return the format
  if(this.id &amp;&amp; this.id.copy) {
    return this.id.toString(typeof format === 'string' ? format : 'hex');
  }

  // if(this.buffer )
  return this.<span class="apidocCodeKeywordSpan">toHexString</span>();
};

/**
* Converts to a string representation of this Id.
*
* @return {String} return the 24 byte hex string representation.
* @ignore
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.ObjectID.prototype.toJSON" id="apidoc.element.bson.ObjectID.prototype.toJSON">
        function <span class="apidocSignatureSpan">bson.ObjectID.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  return this.toHexString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

	'use strict';
	var $export     = __webpack_require__(8)
	  , toObject    = __webpack_require__(58)
	  , toPrimitive = __webpack_require__(16);

	$export($export.P + $export.F * __webpack_require__(7)(function(){
	  return new Date(NaN).<span class="apidocCodeKeywordSpan">toJSON</span>() !== null || Date.prototype.toJSON.call({toISOString:
function(){ return 1; }}) !== 1;
	}), 'Date', {
	  toJSON: function toJSON(key){
	    var O  = toObject(this)
	      , pv = toPrimitive(O);
	    return typeof pv == 'number' &amp;&amp; !isFinite(pv) ? null : O.toISOString();
	  }
	});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.ObjectID.prototype.toString" id="apidoc.element.bson.ObjectID.prototype.toString">
        function <span class="apidocSignatureSpan">bson.ObjectID.prototype.</span>toString
        <span class="apidocSignatureSpan">(format)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function (format) {
  // Is the id a buffer then use the buffer toString method to return the format
  if(this.id &amp;&amp; this.id.copy) {
    return this.id.toString(typeof format === 'string' ? format : 'hex');
  }

  // if(this.buffer )
  return this.toHexString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/***/ },
/* 19 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).<span class="apidocCodeKeywordSpan
">toString</span>(36));
	};

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bson.Symbol" id="apidoc.module.bson.Symbol">module bson.Symbol</a></h1>


    <h2>
        <a href="#apidoc.element.bson.Symbol.Symbol" id="apidoc.element.bson.Symbol.Symbol">
        function <span class="apidocSignatureSpan">bson.</span>Symbol
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Symbol(value) {
  if(!(this instanceof Symbol)) return new Symbol(value);
  this._bsontype = 'Symbol';
  this.value = value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bson.Symbol.prototype" id="apidoc.module.bson.Symbol.prototype">module bson.Symbol.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.bson.Symbol.prototype.inspect" id="apidoc.element.bson.Symbol.prototype.inspect">
        function <span class="apidocSignatureSpan">bson.Symbol.prototype.</span>inspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function () {
  return this.value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Symbol.prototype.toJSON" id="apidoc.element.bson.Symbol.prototype.toJSON">
        function <span class="apidocSignatureSpan">bson.Symbol.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  return this.value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

	'use strict';
	var $export     = __webpack_require__(8)
	  , toObject    = __webpack_require__(58)
	  , toPrimitive = __webpack_require__(16);

	$export($export.P + $export.F * __webpack_require__(7)(function(){
	  return new Date(NaN).<span class="apidocCodeKeywordSpan">toJSON</span>() !== null || Date.prototype.toJSON.call({toISOString:
function(){ return 1; }}) !== 1;
	}), 'Date', {
	  toJSON: function toJSON(key){
	    var O  = toObject(this)
	      , pv = toPrimitive(O);
	    return typeof pv == 'number' &amp;&amp; !isFinite(pv) ? null : O.toISOString();
	  }
	});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Symbol.prototype.toString" id="apidoc.element.bson.Symbol.prototype.toString">
        function <span class="apidocSignatureSpan">bson.Symbol.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return this.value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/***/ },
/* 19 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).<span class="apidocCodeKeywordSpan
">toString</span>(36));
	};

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Symbol.prototype.valueOf" id="apidoc.element.bson.Symbol.prototype.valueOf">
        function <span class="apidocSignatureSpan">bson.Symbol.prototype.</span>valueOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">valueOf = function () {
  return this.value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bson.Timestamp" id="apidoc.module.bson.Timestamp">module bson.Timestamp</a></h1>


    <h2>
        <a href="#apidoc.element.bson.Timestamp.Timestamp" id="apidoc.element.bson.Timestamp.Timestamp">
        function <span class="apidocSignatureSpan">bson.</span>Timestamp
        <span class="apidocSignatureSpan">(low, high)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Timestamp(low, high) {
  if(!(this instanceof Timestamp)) return new Timestamp(low, high);
  this._bsontype = 'Timestamp';
<span class="apidocCodeCommentSpan">  /**
   * @type {number}
   * @ignore
   */
</span>  this.low_ = low | 0;  // force into 32 signed bits.

  /**
   * @type {number}
   * @ignore
   */
  this.high_ = high | 0;  // force into 32 signed bits.
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Timestamp.fromBits" id="apidoc.element.bson.Timestamp.fromBits">
        function <span class="apidocSignatureSpan">bson.Timestamp.</span>fromBits
        <span class="apidocSignatureSpan">(lowBits, highBits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromBits = function (lowBits, highBits) {
  return new Timestamp(lowBits, highBits);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 c32 += c16 &gt;&gt;&gt; 16;
 c16 &amp;= 0xFFFF;
 c32 += a32 + b32;
 c48 += c32 &gt;&gt;&gt; 16;
 c32 &amp;= 0xFFFF;
 c48 += a48 + b48;
 c48 &amp;= 0xFFFF;
 return Long.<span class="apidocCodeKeywordSpan">fromBits</span>((c16 &lt;&lt; 16) | c00, (c48 &lt;&lt; 16) | c32);
};

/**
* Returns the difference of this and the given Long.
*
* @method
* @param {Long} other Long to subtract from this.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Timestamp.fromInt" id="apidoc.element.bson.Timestamp.fromInt">
        function <span class="apidocSignatureSpan">bson.Timestamp.</span>fromInt
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromInt = function (value) {
  if (-128 &lt;= value &amp;&amp; value &lt; 128) {
    var cachedObj = Timestamp.INT_CACHE_[value];
    if (cachedObj) {
      return cachedObj;
    }
  }

  var obj = new Timestamp(value | 0, value &lt; 0 ? -1 : 0);
  if (-128 &lt;= value &amp;&amp; value &lt; 128) {
    Timestamp.INT_CACHE_[value] = obj;
  }
  return obj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * @type {number}
 * @ignore
 */
Long.TWO_PWR_63_DBL_ = Long.TWO_PWR_64_DBL_ / 2;

/** @type {Long} */
Long.ZERO = Long.<span class="apidocCodeKeywordSpan">fromInt</span>(0);

/** @type {Long} */
Long.ONE = Long.fromInt(1);

/** @type {Long} */
Long.NEG_ONE = Long.fromInt(-1);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Timestamp.fromNumber" id="apidoc.element.bson.Timestamp.fromNumber">
        function <span class="apidocSignatureSpan">bson.Timestamp.</span>fromNumber
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromNumber = function (value) {
  if (isNaN(value) || !isFinite(value)) {
    return Timestamp.ZERO;
  } else if (value &lt;= -Timestamp.TWO_PWR_63_DBL_) {
    return Timestamp.MIN_VALUE;
  } else if (value + 1 &gt;= Timestamp.TWO_PWR_63_DBL_) {
    return Timestamp.MAX_VALUE;
  } else if (value &lt; 0) {
    return Timestamp.fromNumber(-value).negate();
  } else {
    return new Timestamp(
               (value % Timestamp.TWO_PWR_32_DBL_) | 0,
               (value / Timestamp.TWO_PWR_32_DBL_) | 0);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  function start() {
    // Get the Long type
    var Long = BSON.Long;
    // Create a bson parser instance
    var bson = new BSON();

    // Serialize document
    var doc = { long: Long.<span class="apidocCodeKeywordSpan">fromNumber</span>(100) }

    // Serialize a document
    var data = bson.serialize(doc)
    // De serialize it again
    var doc_2 = bson.deserialize(data)
  }
&lt;/script&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Timestamp.fromString" id="apidoc.element.bson.Timestamp.fromString">
        function <span class="apidocSignatureSpan">bson.Timestamp.</span>fromString
        <span class="apidocSignatureSpan">(str, opt_radix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromString = function (str, opt_radix) {
  if (str.length == 0) {
    throw Error('number format error: empty string');
  }

  var radix = opt_radix || 10;
  if (radix &lt; 2 || 36 &lt; radix) {
    throw Error('radix out of range: ' + radix);
  }

  if (str.charAt(0) == '-') {
    return Timestamp.fromString(str.substring(1), radix).negate();
  } else if (str.indexOf('-') &gt;= 0) {
    throw Error('number format error: interior "-" character: ' + str);
  }

  // Do several (8) digits each time through the loop, so as to
  // minimize the calls to the very expensive emulated div.
  var radixToPower = Timestamp.fromNumber(Math.pow(radix, 8));

  var result = Timestamp.ZERO;
  for (var i = 0; i &lt; str.length; i += 8) {
    var size = Math.min(8, str.length - i);
    var value = parseInt(str.substring(i, i + size), radix);
    if (size &lt; 8) {
      var power = Timestamp.fromNumber(Math.pow(radix, size));
      result = result.multiply(power).add(Timestamp.fromNumber(value));
    } else {
      result = result.multiply(radixToPower);
      result = result.add(Timestamp.fromNumber(value));
    }
  }
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  for(; dIdx &lt;= lastDigit; dIdx++) {
    significandLow = significandLow.multiply(Long.fromNumber(10));
    significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));
  }
}

var significand = multiply64x2(significandHigh, Long.<span class="apidocCodeKeywordSpan">fromString</span>("100000000000000000
"));

significand.low = significand.low.add(significandLow);

if(lessThan(significand.low, significandLow)) {
  significand.high = significand.high.add(Long.fromNumber(1));
}
...</pre></li>
    </ul>






























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bson.Timestamp.prototype" id="apidoc.module.bson.Timestamp.prototype">module bson.Timestamp.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.bson.Timestamp.prototype.add" id="apidoc.element.bson.Timestamp.prototype.add">
        function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>add
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (other) {
  // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

  var a48 = this.high_ &gt;&gt;&gt; 16;
  var a32 = this.high_ &amp; 0xFFFF;
  var a16 = this.low_ &gt;&gt;&gt; 16;
  var a00 = this.low_ &amp; 0xFFFF;

  var b48 = other.high_ &gt;&gt;&gt; 16;
  var b32 = other.high_ &amp; 0xFFFF;
  var b16 = other.low_ &gt;&gt;&gt; 16;
  var b00 = other.low_ &amp; 0xFFFF;

  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 + b00;
  c16 += c00 &gt;&gt;&gt; 16;
  c00 &amp;= 0xFFFF;
  c16 += a16 + b16;
  c32 += c16 &gt;&gt;&gt; 16;
  c16 &amp;= 0xFFFF;
  c32 += a32 + b32;
  c48 += c32 &gt;&gt;&gt; 16;
  c32 &amp;= 0xFFFF;
  c48 += a48 + b48;
  c48 &amp;= 0xFFFF;
  return Timestamp.fromBits((c16 &lt;&lt; 16) | c00, (c48 &lt;&lt; 16) | c32);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	'use strict';
	var strong = __webpack_require__(212);

	// 23.2 Set Objects
	module.exports = __webpack_require__(213)('Set', function(get){
	  return function Set(){ return get(this, arguments.length &gt; 0 ? arguments[0] : undefined); };
	}, {
	  // 23.2.3.1 Set.prototype.<span class="apidocCodeKeywordSpan">add</span>(value)
	  add: function add(value){
	    return strong.def(this, value = value === 0 ? 0 : value, value);
	  }
	}, strong);

/***/ },
/* 215 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Timestamp.prototype.and" id="apidoc.element.bson.Timestamp.prototype.and">
        function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>and
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">and = function (other) {
  return Timestamp.fromBits(this.low_ &amp; other.low_, this.high_ &amp; other.high_);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// Biased exponent
var biasedExponent = (exponent + EXPONENT_BIAS);
var dec = { low: Long.fromNumber(0), high: Long.fromNumber(0) };

// Encode combination, exponent, and significand.
if(significand.high.shiftRightUnsigned(49).<span class="apidocCodeKeywordSpan">and</span>(Long.fromNumber(1)).equals(Long.fromNumber
)) {
  // Encode '11' into bits 1 to 3
  dec.high = dec.high.or(Long.fromNumber(0x3).shiftLeft(61));
  dec.high = dec.high.or(Long.fromNumber(biasedExponent).and(Long.fromNumber(0x3fff).shiftLeft(47)));
  dec.high = dec.high.or(significand.high.and(Long.fromNumber(0x7fffffffffff)));
} else {
  dec.high = dec.high.or(Long.fromNumber(biasedExponent &amp; 0x3fff).shiftLeft(49));
  dec.high = dec.high.or(significand.high.and(Long.fromNumber(0x1ffffffffffff)));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Timestamp.prototype.compare" id="apidoc.element.bson.Timestamp.prototype.compare">
        function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>compare
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compare = function (other) {
  if (this.equals(other)) {
    return 0;
  }

  var thisNeg = this.isNegative();
  var otherNeg = other.isNegative();
  if (thisNeg &amp;&amp; !otherNeg) {
    return -1;
  }
  if (!thisNeg &amp;&amp; otherNeg) {
    return 1;
  }

  // at this point, the signs are the same, so subtraction will not overflow
  if (this.subtract(other).isNegative()) {
    return -1;
  } else {
    return 1;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Return whether this Long is less than the other.
*
* @method
* @param {Long} other Long to compare against.
* @return {boolean} whether this Long is less than the other.
*/
Long.prototype.lessThan = function(other) {
 return this.<span class="apidocCodeKeywordSpan">compare</span>(other) &lt; 0;
};

/**
* Return whether this Long is less than or equal to the other.
*
* @method
* @param {Long} other Long to compare against.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Timestamp.prototype.div" id="apidoc.element.bson.Timestamp.prototype.div">
        function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>div
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">div = function (other) {
  if (other.isZero()) {
    throw Error('division by zero');
  } else if (this.isZero()) {
    return Timestamp.ZERO;
  }

  if (this.equals(Timestamp.MIN_VALUE)) {
    if (other.equals(Timestamp.ONE) ||
        other.equals(Timestamp.NEG_ONE)) {
      return Timestamp.MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
    } else if (other.equals(Timestamp.MIN_VALUE)) {
      return Timestamp.ONE;
    } else {
      // At this point, we have |other| &gt;= 2, so |this/other| &lt; |MIN_VALUE|.
      var halfThis = this.shiftRight(1);
      var approx = halfThis.div(other).shiftLeft(1);
      if (approx.equals(Timestamp.ZERO)) {
        return other.isNegative() ? Timestamp.ONE : Timestamp.NEG_ONE;
      } else {
        var rem = this.subtract(other.multiply(approx));
        var result = approx.add(rem.div(other));
        return result;
      }
    }
  } else if (other.equals(Timestamp.MIN_VALUE)) {
    return Timestamp.ZERO;
  }

  if (this.isNegative()) {
    if (other.isNegative()) {
      return this.negate().div(other.negate());
    } else {
      return this.negate().div(other).negate();
    }
  } else if (other.isNegative()) {
    return this.div(other.negate()).negate();
  }

  // Repeat the following until the remainder is less than other:  find a
  // floating-point that approximates remainder / other *from below*, add this
  // into the result, and subtract it from the remainder.  It is critical that
  // the approximate value is less than or equal to the real value so that the
  // remainder never becomes negative.
  var res = Timestamp.ZERO;
  var rem = this;
  while (rem.greaterThanOrEqual(other)) {
    // Approximate the result of division. This may be a little greater or
    // smaller than the actual value.
    var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));

    // We will tweak the approximate result by changing it in the 48-th digit or
    // the smallest non-fractional digit, whichever is larger.
    var log2 = Math.ceil(Math.log(approx) / Math.LN2);
    var delta = (log2 &lt;= 48) ? 1 : Math.pow(2, log2 - 48);

    // Decrease the approximation until it is smaller than the remainder.  Note
    // that if it is too large, the product overflows and is negative.
    var approxRes = Timestamp.fromNumber(approx);
    var approxRem = approxRes.multiply(other);
    while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
      approx -= delta;
      approxRes = Timestamp.fromNumber(approx);
      approxRem = approxRes.multiply(other);
    }

    // We know the answer can't be zero... and actually, zero would cause
    // infinite recursion since we would make no progress.
    if (approxRes.isZero()) {
      approxRes = Timestamp.ONE;
    }

    res = res.add(approxRes);
    rem = rem.subtract(approxRem);
  }
  return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  for(var i = 0; i &lt;= 3; i++) {
    // Adjust remainder to match value of next dividend
    _rem = _rem.shiftLeft(32);
    // Add the divided to _rem
    _rem = _rem.add(new Long(value.parts[i], 0));
    value.parts[i] = _rem.<span class="apidocCodeKeywordSpan">div</span>(DIVISOR).low_;
    _rem = _rem.modulo(DIVISOR);
  }

  return { quotient: value, rem: _rem };
}

// Multiply two Long values and return the 128 bit value
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Timestamp.prototype.equals" id="apidoc.element.bson.Timestamp.prototype.equals">
        function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>equals
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">equals = function (other) {
  return (this.high_ == other.high_) &amp;&amp; (this.low_ == other.low_);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// Biased exponent
var biasedExponent = (exponent + EXPONENT_BIAS);
var dec = { low: Long.fromNumber(0), high: Long.fromNumber(0) };

// Encode combination, exponent, and significand.
if(significand.high.shiftRightUnsigned(49).and(Long.fromNumber(1)).<span class="apidocCodeKeywordSpan">equals</span>(Long.fromNumber
)) {
  // Encode '11' into bits 1 to 3
  dec.high = dec.high.or(Long.fromNumber(0x3).shiftLeft(61));
  dec.high = dec.high.or(Long.fromNumber(biasedExponent).and(Long.fromNumber(0x3fff).shiftLeft(47)));
  dec.high = dec.high.or(significand.high.and(Long.fromNumber(0x7fffffffffff)));
} else {
  dec.high = dec.high.or(Long.fromNumber(biasedExponent &amp; 0x3fff).shiftLeft(49));
  dec.high = dec.high.or(significand.high.and(Long.fromNumber(0x1ffffffffffff)));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Timestamp.prototype.getHighBits" id="apidoc.element.bson.Timestamp.prototype.getHighBits">
        function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>getHighBits
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getHighBits = function () {
  return this.high_;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Number of written bytes
var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
// Encode the name
index = index + numberOfWrittenBytes;
buffer[index++] = 0;
var longVal = Long.fromNumber(value);
var lowBits = longVal.getLowBits();
var highBits = longVal.<span class="apidocCodeKeywordSpan">getHighBits</span>();
// Encode low bits
buffer[index++] = lowBits &amp; 0xff;
buffer[index++] = (lowBits &gt;&gt; 8) &amp; 0xff;
buffer[index++] = (lowBits &gt;&gt; 16) &amp; 0xff;
buffer[index++] = (lowBits &gt;&gt; 24) &amp; 0xff;
// Encode high bits
buffer[index++] = highBits &amp; 0xff;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Timestamp.prototype.getLowBits" id="apidoc.element.bson.Timestamp.prototype.getLowBits">
        function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>getLowBits
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLowBits = function () {
  return this.low_;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Multiply two Long values and return the 128 bit value
var multiply64x2 = function(left, right) {
if(!left &amp;&amp; !right) {
  return {high: Long.fromNumber(0), low: Long.fromNumber(0)};
}

var leftHigh = left.shiftRightUnsigned(32);
var leftLow = new Long(left.<span class="apidocCodeKeywordSpan">getLowBits</span>(), 0);
var rightHigh = right.shiftRightUnsigned(32);
var rightLow = new Long(right.getLowBits(), 0);

var productHigh = leftHigh.multiply(rightHigh);
var productMid = leftHigh.multiply(rightLow);
var productMid2 = leftLow.multiply(rightHigh);
var productLow = leftLow.multiply(rightLow);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Timestamp.prototype.getLowBitsUnsigned" id="apidoc.element.bson.Timestamp.prototype.getLowBitsUnsigned">
        function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>getLowBitsUnsigned
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLowBitsUnsigned = function () {
  return (this.low_ &gt;= 0) ?
      this.low_ : Timestamp.TWO_PWR_32_DBL_ + this.low_;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Return the Number value.
*
* @method
* @return {number} the closest floating-point representation to this value.
*/
Long.prototype.toNumber = function() {
 return this.high_ * Long.TWO_PWR_32_DBL_ +
        this.<span class="apidocCodeKeywordSpan">getLowBitsUnsigned</span>();
};

/**
* Return the JSON value.
*
* @method
* @return {string} the JSON representation.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Timestamp.prototype.getNumBitsAbs" id="apidoc.element.bson.Timestamp.prototype.getNumBitsAbs">
        function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>getNumBitsAbs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getNumBitsAbs = function () {
  if (this.isNegative()) {
    if (this.equals(Timestamp.MIN_VALUE)) {
      return 64;
    } else {
      return this.negate().getNumBitsAbs();
    }
  } else {
    var val = this.high_ != 0 ? this.high_ : this.low_;
    for (var bit = 31; bit &gt; 0; bit--) {
      if ((val &amp; (1 &lt;&lt; bit)) != 0) {
        break;
      }
    }
    return this.high_ != 0 ? bit + 33 : bit + 1;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {number} Returns the number of bits needed to represent the absolute value of this Long.
 */
Long.prototype.getNumBitsAbs = function() {
if (this.isNegative()) {
  if (this.equals(Long.MIN_VALUE)) {
    return 64;
  } else {
    return this.negate().<span class="apidocCodeKeywordSpan">getNumBitsAbs</span>();
  }
} else {
  var val = this.high_ != 0 ? this.high_ : this.low_;
  for (var bit = 31; bit &gt; 0; bit--) {
    if ((val &amp; (1 &lt;&lt; bit)) != 0) {
      break;
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Timestamp.prototype.greaterThan" id="apidoc.element.bson.Timestamp.prototype.greaterThan">
        function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>greaterThan
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">greaterThan = function (other) {
  return this.compare(other) &gt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var log2 = Math.ceil(Math.log(approx) / Math.LN2);
var delta = (log2 &lt;= 48) ? 1 : Math.pow(2, log2 - 48);

// Decrease the approximation until it is smaller than the remainder.  Note
// that if it is too large, the product overflows and is negative.
var approxRes = Long.fromNumber(approx);
var approxRem = approxRes.multiply(other);
while (approxRem.isNegative() || approxRem.<span class="apidocCodeKeywordSpan">greaterThan</span>(rem)) {
  approx -= delta;
  approxRes = Long.fromNumber(approx);
  approxRem = approxRes.multiply(other);
}

// We know the answer can't be zero... and actually, zero would cause
// infinite recursion since we would make no progress.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Timestamp.prototype.greaterThanOrEqual" id="apidoc.element.bson.Timestamp.prototype.greaterThanOrEqual">
        function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>greaterThanOrEqual
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">greaterThanOrEqual = function (other) {
  return this.compare(other) &gt;= 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // Repeat the following until the remainder is less than other:  find a
  // floating-point that approximates remainder / other *from below*, add this
  // into the result, and subtract it from the remainder.  It is critical that
  // the approximate value is less than or equal to the real value so that the
  // remainder never becomes negative.
  var res = Long.ZERO;
  var rem = this;
  while (rem.<span class="apidocCodeKeywordSpan">greaterThanOrEqual</span>(other)) {
// Approximate the result of division. This may be a little greater or
// smaller than the actual value.
var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));

// We will tweak the approximate result by changing it in the 48-th digit or
// the smallest non-fractional digit, whichever is larger.
var log2 = Math.ceil(Math.log(approx) / Math.LN2);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Timestamp.prototype.isNegative" id="apidoc.element.bson.Timestamp.prototype.isNegative">
        function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>isNegative
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNegative = function () {
  return this.high_ &lt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  throw Error('radix out of range: ' + radix);
}

if (this.isZero()) {
  return '0';
}

if (this.<span class="apidocCodeKeywordSpan">isNegative</span>()) {
  if (this.equals(Long.MIN_VALUE)) {
    // We need to change the Long value before it can be negated, so we remove
    // the bottom-most digit in this base and then recurse to do the rest.
    var radixLong = Long.fromNumber(radix);
    var div = this.div(radixLong);
    var rem = div.multiply(radixLong).subtract(this);
    return div.toString(radix) + rem.toInt().toString(radix);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Timestamp.prototype.isOdd" id="apidoc.element.bson.Timestamp.prototype.isOdd">
        function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>isOdd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isOdd = function () {
  return (this.low_ &amp; 1) == 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.isZero()) {
  return Long.ZERO;
} else if (other.isZero()) {
  return Long.ZERO;
}

if (this.equals(Long.MIN_VALUE)) {
  return other.<span class="apidocCodeKeywordSpan">isOdd</span>() ? Long.MIN_VALUE : Long.ZERO;
} else if (other.equals(Long.MIN_VALUE)) {
  return this.isOdd() ? Long.MIN_VALUE : Long.ZERO;
}

if (this.isNegative()) {
  if (other.isNegative()) {
    return this.negate().multiply(other.negate());
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Timestamp.prototype.isZero" id="apidoc.element.bson.Timestamp.prototype.isZero">
        function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>isZero
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isZero = function () {
  return this.high_ == 0 &amp;&amp; this.low_ == 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
Long.prototype.toString = function(opt_radix) {
var radix = opt_radix || 10;
if (radix &lt; 2 || 36 &lt; radix) {
  throw Error('radix out of range: ' + radix);
}

if (this.<span class="apidocCodeKeywordSpan">isZero</span>()) {
  return '0';
}

if (this.isNegative()) {
  if (this.equals(Long.MIN_VALUE)) {
    // We need to change the Long value before it can be negated, so we remove
    // the bottom-most digit in this base and then recurse to do the rest.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Timestamp.prototype.lessThan" id="apidoc.element.bson.Timestamp.prototype.lessThan">
        function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>lessThan
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lessThan = function (other) {
  return this.compare(other) &lt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var index = 0;

// Create the state of the decimal
var dec = {
  low: new Long(low, midl),
  high: new Long(midh, high) };

if(dec.high.<span class="apidocCodeKeywordSpan">lessThan</span>(Long.ZERO)) {
  string.push('-');
}

// Decode combination field and exponent
combination = (high &gt;&gt; 26) &amp; COMBINATION_MASK;

if((combination &gt;&gt; 3) == 3) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Timestamp.prototype.lessThanOrEqual" id="apidoc.element.bson.Timestamp.prototype.lessThanOrEqual">
        function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>lessThanOrEqual
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lessThanOrEqual = function (other) {
  return this.compare(other) &lt;= 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		} else if(elementType == BSON.BSON_DATA_LONG) {
      // Unpack the low and high bits
      var lowBits = buffer[index++] | buffer[index++] &lt;&lt; 8 | buffer[index++] &lt;&lt; 16 | buffer[index++] &lt;&amp;#
x3c; 24;
      var highBits = buffer[index++] | buffer[index++] &lt;&lt; 8 | buffer[index++] &lt;&lt; 16 | buffer[index++] &lt;&amp;#
x3c; 24;
      var long = new Long(lowBits, highBits);
      // Promote the long if possible
      if(promoteLongs &amp;&amp; promoteValues == true) {
        object[name] = long.<span class="apidocCodeKeywordSpan">lessThanOrEqual</span>(JS_INT_MAX_LONG) &amp;&amp; long.greaterThanOrEqual
(JS_INT_MIN_LONG) ? long.toNumber() : long;
      } else {
        object[name] = long;
      }
		} else if(elementType == BSON.BSON_DATA_DECIMAL128) {
			// Buffer to contain the decimal bytes
			var bytes = new Buffer(16);
			// Copy the next 16 bytes into the bytes buffer
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Timestamp.prototype.modulo" id="apidoc.element.bson.Timestamp.prototype.modulo">
        function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>modulo
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">modulo = function (other) {
  return this.subtract(this.div(other).multiply(other));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  for(var i = 0; i &lt;= 3; i++) {
    // Adjust remainder to match value of next dividend
    _rem = _rem.shiftLeft(32);
    // Add the divided to _rem
    _rem = _rem.add(new Long(value.parts[i], 0));
    value.parts[i] = _rem.div(DIVISOR).low_;
    _rem = _rem.<span class="apidocCodeKeywordSpan">modulo</span>(DIVISOR);
  }

  return { quotient: value, rem: _rem };
}

// Multiply two Long values and return the 128 bit value
var multiply64x2 = function(left, right) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Timestamp.prototype.multiply" id="apidoc.element.bson.Timestamp.prototype.multiply">
        function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>multiply
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">multiply = function (other) {
  if (this.isZero()) {
    return Timestamp.ZERO;
  } else if (other.isZero()) {
    return Timestamp.ZERO;
  }

  if (this.equals(Timestamp.MIN_VALUE)) {
    return other.isOdd() ? Timestamp.MIN_VALUE : Timestamp.ZERO;
  } else if (other.equals(Timestamp.MIN_VALUE)) {
    return this.isOdd() ? Timestamp.MIN_VALUE : Timestamp.ZERO;
  }

  if (this.isNegative()) {
    if (other.isNegative()) {
      return this.negate().multiply(other.negate());
    } else {
      return this.negate().multiply(other).negate();
    }
  } else if (other.isNegative()) {
    return this.multiply(other.negate()).negate();
  }

  // If both Timestamps are small, use float multiplication
  if (this.lessThan(Timestamp.TWO_PWR_24_) &amp;&amp;
      other.lessThan(Timestamp.TWO_PWR_24_)) {
    return Timestamp.fromNumber(this.toNumber() * other.toNumber());
  }

  // Divide each Timestamp into 4 chunks of 16 bits, and then add up 4x4 products.
  // We can skip products that would overflow.

  var a48 = this.high_ &gt;&gt;&gt; 16;
  var a32 = this.high_ &amp; 0xFFFF;
  var a16 = this.low_ &gt;&gt;&gt; 16;
  var a00 = this.low_ &amp; 0xFFFF;

  var b48 = other.high_ &gt;&gt;&gt; 16;
  var b32 = other.high_ &amp; 0xFFFF;
  var b16 = other.low_ &gt;&gt;&gt; 16;
  var b00 = other.low_ &amp; 0xFFFF;

  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 * b00;
  c16 += c00 &gt;&gt;&gt; 16;
  c00 &amp;= 0xFFFF;
  c16 += a16 * b00;
  c32 += c16 &gt;&gt;&gt; 16;
  c16 &amp;= 0xFFFF;
  c16 += a00 * b16;
  c32 += c16 &gt;&gt;&gt; 16;
  c16 &amp;= 0xFFFF;
  c32 += a32 * b00;
  c48 += c32 &gt;&gt;&gt; 16;
  c32 &amp;= 0xFFFF;
  c32 += a16 * b16;
  c48 += c32 &gt;&gt;&gt; 16;
  c32 &amp;= 0xFFFF;
  c32 += a00 * b32;
  c48 += c32 &gt;&gt;&gt; 16;
  c32 &amp;= 0xFFFF;
  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
  c48 &amp;= 0xFFFF;
  return Timestamp.fromBits((c16 &lt;&lt; 16) | c00, (c48 &lt;&lt; 16) | c32);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

var leftHigh = left.shiftRightUnsigned(32);
var leftLow = new Long(left.getLowBits(), 0);
var rightHigh = right.shiftRightUnsigned(32);
var rightLow = new Long(right.getLowBits(), 0);

var productHigh = leftHigh.<span class="apidocCodeKeywordSpan">multiply</span>(rightHigh);
var productMid = leftHigh.multiply(rightLow);
var productMid2 = leftLow.multiply(rightHigh);
var productLow = leftLow.multiply(rightLow);

productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
productMid = new Long(productMid.getLowBits(), 0)
              .add(productMid2)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Timestamp.prototype.negate" id="apidoc.element.bson.Timestamp.prototype.negate">
        function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>negate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">negate = function () {
  if (this.equals(Timestamp.MIN_VALUE)) {
    return Timestamp.MIN_VALUE;
  } else {
    return this.not().add(Timestamp.ONE);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // We need to change the Long value before it can be negated, so we remove
    // the bottom-most digit in this base and then recurse to do the rest.
    var radixLong = Long.fromNumber(radix);
    var div = this.div(radixLong);
    var rem = div.multiply(radixLong).subtract(this);
    return div.toString(radix) + rem.toInt().toString(radix);
  } else {
    return '-' + this.<span class="apidocCodeKeywordSpan">negate</span>().toString(radix);
  }
}

// Do several (6) digits each time through the loop, so as to
// minimize the calls to the very expensive emulated div.
var radixToPower = Long.fromNumber(Math.pow(radix, 6));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Timestamp.prototype.not" id="apidoc.element.bson.Timestamp.prototype.not">
        function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>not
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">not = function () {
  return Timestamp.fromBits(~this.low_, ~this.high_);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @method
* @return {Long} the negation of this value.
*/
Long.prototype.negate = function() {
 if (this.equals(Long.MIN_VALUE)) {
   return Long.MIN_VALUE;
 } else {
   return this.<span class="apidocCodeKeywordSpan">not</span>().add(Long.ONE);
 }
};

/**
* Returns the sum of this and the given Long.
*
* @method
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Timestamp.prototype.notEquals" id="apidoc.element.bson.Timestamp.prototype.notEquals">
        function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>notEquals
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notEquals = function (other) {
  return (this.high_ != other.high_) || (this.low_ != other.low_);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Timestamp.prototype.or" id="apidoc.element.bson.Timestamp.prototype.or">
        function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>or
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">or = function (other) {
  return Timestamp.fromBits(this.low_ | other.low_, this.high_ | other.high_);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Biased exponent
var biasedExponent = (exponent + EXPONENT_BIAS);
var dec = { low: Long.fromNumber(0), high: Long.fromNumber(0) };

// Encode combination, exponent, and significand.
if(significand.high.shiftRightUnsigned(49).and(Long.fromNumber(1)).equals(Long.fromNumber)) {
  // Encode '11' into bits 1 to 3
  dec.high = dec.high.<span class="apidocCodeKeywordSpan">or</span>(Long.fromNumber(0x3).shiftLeft(61));
  dec.high = dec.high.or(Long.fromNumber(biasedExponent).and(Long.fromNumber(0x3fff).shiftLeft(47)));
  dec.high = dec.high.or(significand.high.and(Long.fromNumber(0x7fffffffffff)));
} else {
  dec.high = dec.high.or(Long.fromNumber(biasedExponent &amp; 0x3fff).shiftLeft(49));
  dec.high = dec.high.or(significand.high.and(Long.fromNumber(0x1ffffffffffff)));
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Timestamp.prototype.shiftLeft" id="apidoc.element.bson.Timestamp.prototype.shiftLeft">
        function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>shiftLeft
        <span class="apidocSignatureSpan">(numBits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shiftLeft = function (numBits) {
  numBits &amp;= 63;
  if (numBits == 0) {
    return this;
  } else {
    var low = this.low_;
    if (numBits &lt; 32) {
      var high = this.high_;
      return Timestamp.fromBits(
                 low &lt;&lt; numBits,
                 (high &lt;&lt; numBits) | (low &gt;&gt;&gt; (32 - numBits)));
    } else {
      return Timestamp.fromBits(0, low &lt;&lt; (numBits - 32));
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(!value.parts[0] &amp;&amp; !value.parts[1] &amp;&amp;
   !value.parts[2] &amp;&amp; !value.parts[3]) {
  return { quotient: value, rem: _rem };
}

for(var i = 0; i &lt;= 3; i++) {
  // Adjust remainder to match value of next dividend
  _rem = _rem.<span class="apidocCodeKeywordSpan">shiftLeft</span>(32);
  // Add the divided to _rem
  _rem = _rem.add(new Long(value.parts[i], 0));
  value.parts[i] = _rem.div(DIVISOR).low_;
  _rem = _rem.modulo(DIVISOR);
}

return { quotient: value, rem: _rem };
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Timestamp.prototype.shiftRight" id="apidoc.element.bson.Timestamp.prototype.shiftRight">
        function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>shiftRight
        <span class="apidocSignatureSpan">(numBits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shiftRight = function (numBits) {
  numBits &amp;= 63;
  if (numBits == 0) {
    return this;
  } else {
    var high = this.high_;
    if (numBits &lt; 32) {
      var low = this.low_;
      return Timestamp.fromBits(
                 (low &gt;&gt;&gt; numBits) | (high &lt;&lt; (32 - numBits)),
                 high &gt;&gt; numBits);
    } else {
      return Timestamp.fromBits(
                 high &gt;&gt; (numBits - 32),
                 high &gt;= 0 ? 0 : -1);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (other.equals(Long.ONE) ||
    other.equals(Long.NEG_ONE)) {
  return Long.MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
} else if (other.equals(Long.MIN_VALUE)) {
  return Long.ONE;
} else {
  // At this point, we have |other| &gt;= 2, so |this/other| &lt; |MIN_VALUE|.
  var halfThis = this.<span class="apidocCodeKeywordSpan">shiftRight</span>(1);
  var approx = halfThis.div(other).shiftLeft(1);
  if (approx.equals(Long.ZERO)) {
    return other.isNegative() ? Long.ONE : Long.NEG_ONE;
  } else {
    var rem = this.subtract(other.multiply(approx));
    var result = approx.add(rem.div(other));
    return result;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Timestamp.prototype.shiftRightUnsigned" id="apidoc.element.bson.Timestamp.prototype.shiftRightUnsigned">
        function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>shiftRightUnsigned
        <span class="apidocSignatureSpan">(numBits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shiftRightUnsigned = function (numBits) {
  numBits &amp;= 63;
  if (numBits == 0) {
    return this;
  } else {
    var high = this.high_;
    if (numBits &lt; 32) {
      var low = this.low_;
      return Timestamp.fromBits(
                 (low &gt;&gt;&gt; numBits) | (high &lt;&lt; (32 - numBits)),
                 high &gt;&gt;&gt; numBits);
    } else if (numBits == 32) {
      return Timestamp.fromBits(high, 0);
    } else {
      return Timestamp.fromBits(high &gt;&gt;&gt; (numBits - 32), 0);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Multiply two Long values and return the 128 bit value
var multiply64x2 = function(left, right) {
if(!left &amp;&amp; !right) {
  return {high: Long.fromNumber(0), low: Long.fromNumber(0)};
}

var leftHigh = left.<span class="apidocCodeKeywordSpan">shiftRightUnsigned</span>(32);
var leftLow = new Long(left.getLowBits(), 0);
var rightHigh = right.shiftRightUnsigned(32);
var rightLow = new Long(right.getLowBits(), 0);

var productHigh = leftHigh.multiply(rightHigh);
var productMid = leftHigh.multiply(rightLow);
var productMid2 = leftLow.multiply(rightHigh);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Timestamp.prototype.subtract" id="apidoc.element.bson.Timestamp.prototype.subtract">
        function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>subtract
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subtract = function (other) {
  return this.add(other.negate());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (this.isNegative()) {
  if (this.equals(Long.MIN_VALUE)) {
    // We need to change the Long value before it can be negated, so we remove
    // the bottom-most digit in this base and then recurse to do the rest.
    var radixLong = Long.fromNumber(radix);
    var div = this.div(radixLong);
    var rem = div.multiply(radixLong).<span class="apidocCodeKeywordSpan">subtract</span>(this);
    return div.toString(radix) + rem.toInt().toString(radix);
  } else {
    return '-' + this.negate().toString(radix);
  }
}

// Do several (6) digits each time through the loop, so as to
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Timestamp.prototype.toInt" id="apidoc.element.bson.Timestamp.prototype.toInt">
        function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>toInt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toInt = function () {
  return this.low_;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.isNegative()) {
  if (this.equals(Long.MIN_VALUE)) {
    // We need to change the Long value before it can be negated, so we remove
    // the bottom-most digit in this base and then recurse to do the rest.
    var radixLong = Long.fromNumber(radix);
    var div = this.div(radixLong);
    var rem = div.multiply(radixLong).subtract(this);
    return div.toString(radix) + rem.<span class="apidocCodeKeywordSpan">toInt</span>().toString(radix);
  } else {
    return '-' + this.negate().toString(radix);
  }
}

// Do several (6) digits each time through the loop, so as to
// minimize the calls to the very expensive emulated div.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Timestamp.prototype.toJSON" id="apidoc.element.bson.Timestamp.prototype.toJSON">
        function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  return this.toString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

	'use strict';
	var $export     = __webpack_require__(8)
	  , toObject    = __webpack_require__(58)
	  , toPrimitive = __webpack_require__(16);

	$export($export.P + $export.F * __webpack_require__(7)(function(){
	  return new Date(NaN).<span class="apidocCodeKeywordSpan">toJSON</span>() !== null || Date.prototype.toJSON.call({toISOString:
function(){ return 1; }}) !== 1;
	}), 'Date', {
	  toJSON: function toJSON(key){
	    var O  = toObject(this)
	      , pv = toPrimitive(O);
	    return typeof pv == 'number' &amp;&amp; !isFinite(pv) ? null : O.toISOString();
	  }
	});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Timestamp.prototype.toNumber" id="apidoc.element.bson.Timestamp.prototype.toNumber">
        function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>toNumber
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toNumber = function () {
  return this.high_ * Timestamp.TWO_PWR_32_DBL_ +
         this.getLowBitsUnsigned();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else if (other.isNegative()) {
  return this.multiply(other.negate()).negate();
}

// If both Longs are small, use float multiplication
if (this.lessThan(Long.TWO_PWR_24_) &amp;&amp;
    other.lessThan(Long.TWO_PWR_24_)) {
  return Long.fromNumber(this.<span class="apidocCodeKeywordSpan">toNumber</span>() * other.toNumber());
}

// Divide each Long into 4 chunks of 16 bits, and then add up 4x4 products.
// We can skip products that would overflow.

var a48 = this.high_ &gt;&gt;&gt; 16;
var a32 = this.high_ &amp; 0xFFFF;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Timestamp.prototype.toString" id="apidoc.element.bson.Timestamp.prototype.toString">
        function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>toString
        <span class="apidocSignatureSpan">(opt_radix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function (opt_radix) {
  var radix = opt_radix || 10;
  if (radix &lt; 2 || 36 &lt; radix) {
    throw Error('radix out of range: ' + radix);
  }

  if (this.isZero()) {
    return '0';
  }

  if (this.isNegative()) {
    if (this.equals(Timestamp.MIN_VALUE)) {
      // We need to change the Timestamp value before it can be negated, so we remove
      // the bottom-most digit in this base and then recurse to do the rest.
      var radixTimestamp = Timestamp.fromNumber(radix);
      var div = this.div(radixTimestamp);
      var rem = div.multiply(radixTimestamp).subtract(this);
      return div.toString(radix) + rem.toInt().toString(radix);
    } else {
      return '-' + this.negate().toString(radix);
    }
  }

  // Do several (6) digits each time through the loop, so as to
  // minimize the calls to the very expensive emulated div.
  var radixToPower = Timestamp.fromNumber(Math.pow(radix, 6));

  var rem = this;
  var result = '';
  while (true) {
    var remDiv = rem.div(radixToPower);
    var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
    var digits = intval.toString(radix);

    rem = remDiv;
    if (rem.isZero()) {
      return digits + result;
    } else {
      while (digits.length &lt; 6) {
        digits = '0' + digits;
      }
      result = '' + digits + result;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/***/ },
/* 19 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).<span class="apidocCodeKeywordSpan
">toString</span>(36));
	};

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.Timestamp.prototype.xor" id="apidoc.element.bson.Timestamp.prototype.xor">
        function <span class="apidocSignatureSpan">bson.Timestamp.prototype.</span>xor
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">xor = function (other) {
  return Timestamp.fromBits(this.low_ ^ other.low_, this.high_ ^ other.high_);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bson.float_parser" id="apidoc.module.bson.float_parser">module bson.float_parser</a></h1>


    <h2>
        <a href="#apidoc.element.bson.float_parser.readIEEE754" id="apidoc.element.bson.float_parser.readIEEE754">
        function <span class="apidocSignatureSpan">bson.float_parser.</span>readIEEE754
        <span class="apidocSignatureSpan">(buffer, offset, endian, mLen, nBytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readIEEE754 = function (buffer, offset, endian, mLen, nBytes) {
  var e, m,
      bBE = (endian === 'big'),
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 &lt;&lt; eLen) - 1,
      eBias = eMax &gt;&gt; 1,
      nBits = -7,
      i = bBE ? 0 : (nBytes - 1),
      d = bBE ? 1 : -1,
      s = buffer[offset + i];

  i += d;

  e = s &amp; ((1 &lt;&lt; (-nBits)) - 1);
  s &gt;&gt;= (-nBits);
  nBits += eLen;
  for (; nBits &gt; 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e &amp; ((1 &lt;&lt; (-nBits)) - 1);
  e &gt;&gt;= (-nBits);
  nBits += mLen;
  for (; nBits &gt; 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bson.float_parser.writeIEEE754" id="apidoc.element.bson.float_parser.writeIEEE754">
        function <span class="apidocSignatureSpan">bson.float_parser.</span>writeIEEE754
        <span class="apidocSignatureSpan">(buffer, value, offset, endian, mLen, nBytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeIEEE754 = function (buffer, value, offset, endian, mLen, nBytes) {
  var e, m, c,
      bBE = (endian === 'big'),
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 &lt;&lt; eLen) - 1,
      eBias = eMax &gt;&gt; 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = bBE ? (nBytes-1) : 0,
      d = bBE ? -1 : 1,
      s = value &lt; 0 || (value === 0 &amp;&amp; 1 / value &lt; 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) &lt; 1) {
      e--;
      c *= 2;
    }
    if (e+eBias &gt;= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c &gt;= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias &gt;= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias &gt;= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen &gt;= 8; buffer[offset + i] = m &amp; 0xff, i += d, m /= 256, mLen -= 8);

  e = (e &lt;&lt; mLen) | m;
  eLen += mLen;
  for (; eLen &gt; 0; buffer[offset + i] = e &amp; 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>